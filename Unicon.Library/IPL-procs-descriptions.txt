################################################################################
File:
abkform.icn
********************************************************************************
Description:
Procedures set to read and write HP95LX appointment book (.abk) files.
********************************************************************************
Additional Notes:
1. Files created by the Appointment Book application may contain some padding following the last field of some data records.  Hence, the RecordLength field must be used to determine the start of the next record.  Appointment book files created by other programs need not have any padding.

2. ApptState has several bit fields.  Only bit 0 is meaningful to software processing an appointment book file.  Bit 0 being set or cleared corresponds to the alarm being enabled or disabled, respectively. Programs creating Appointment book files should clear all bits, except perhaps bit 0.

3. ToDoState has two one-bit bit fields.  Bit 0 being set or cleared corresponds to carry forward being enabled or disabled for this todo item, respectively.  Bit 1 being set or cleared corresponds to the todo being checked off or not checked off, respectively.

4. Appointment and ToDo texts are each limited to a maximum of 27 characters.

5. Note text is limited to a maximum of 11 lines of 39 characters per line (not counting the line terminator).
********************************************************************************
Detail Description:
--------------------------------------------------------------------------------
Section:
HP 95LX Appointment Book File Format
The HP 95LX Appointment Book file is structured as a file-identification record, followed by a settings record, followed by a variable number of data records, and terminated by an end-of-file record. There are multiple types of data records corresponding to the different types of appointment book entries.

The formats of these appointment book records is described in the following tables. In the descriptions, the type <int> refers to a two-byte integer stored least significant byte first, the type <swpint> refers to a two-byte integer stored most significant byte first, the type <char> refers to a one-byte integer, and the type <ASCII> refers to a string of ASCII characters.
--------------------------------------------------------------------------------
Section:
HP 95LX Appointment Book File Identification Record:
Byte Offset      Name            Type     Contents

0                ProductCode     int      -1 (FFh, FFh)
2                ReleaseNum      int      1 (01h, 00h)
4                FileType        char     1 (01h)
--------------------------------------------------------------------------------
Section:
HP 95LX Appointment Book Settings Record:
Byte Offset      Name            Type     Contents

0                StartTime       int      Daily display start time as the number of minutes past midnight.
2                Granularity     int      Daily display time line granularity in minutes.
4                AlarmEnable     char     1 = on, 0 = off
5                LeadTime        char     Alarm default lead time in minutes.
6                CarryForward    char     To do carry forward default, 1 = on, 0 = off.
--------------------------------------------------------------------------------
Section:
HP 95LX Appointment Book Daily Data Record:
Byte Offset      Name            Type     Contents

0                RecordType      char     1 (01h)
1                RecordLength    int      Number of bytes in remainder of this data record, see note 1 below.
3                ApptState       char     See note 2 below.
4                Year            char     Year counting from 1900.
5                Month           char     Month, 1 - 12.
6                Day             char     Day, 1 - 31.
7                StartTime       swpint   Start time in minutes since midnight.
9                EndTime         int      End time in minutes since midnight.
11               LeadTime        char     Alarm lead time in minutes, 0 - 30.
12               ApptLength      char     Length of appointment text in bytes.
13               NoteLength      int      Length of note text in bytes.
15               ApptText        ASCII    Appointment text - see note 4 below.
15+ApptLength    NoteText        ASCII    Note text where the null character is used as the line terminator - see note 5.
--------------------------------------------------------------------------------
Section:
HP 95LX Appointment Book Weekly Data Record:
Byte Offset      Name            Type     Contents

0                RecordType      char     2 (02h)
1                RecordLength    int      Number of bytes in remainder of this data record, see note 1 below.
3                ApptState       char     See note 2 below.
4                DayOfWeek       char     Day of week, 1=Sun, ..., 7=Sat.
5                StartTime       swpint   Start time in minutes since midnight.
7                StartYear       char     Start year counting from 1900.
8                StartMonth      char     Start month, 1 - 12.
9                StartDay        char     Start day, 1 - 31.
10               EndTime         int      End time in minutes since midnight.
12               EndYear         char     End year counting from 1900.
13               EndMonth        char     End month, 1 - 12.
14               EndDay          char     End day, 1 - 31.
15               LeadTime        char     Alarm lead time in minutes, 0 - 30.
16               ApptLength      char     Length of appointment text in bytes.
17               NoteLength      int      Length of note text in bytes.
19               ApptText        ASCII    Appointment text - see note 4 below.
19+ApptLength    NoteText        ASCII    Note text where the null character is used as the line terminator - see note 5 below.
--------------------------------------------------------------------------------
Section:
HP 95LX Appointment Book Monthly by Date Data Record:
Byte Offset      Name            Type     Contents

0                RecordType      char     3 (03h)
1                RecordLength    int      Number of bytes in remainder of this data record, see note 1 below.
3                ApptState       char     See note 2 below.
4                DayOfMonth      char     Day of month, 1 - 31.
5                StartTime       swpint   Start time in minutes since midnight.
7                StartYear       char     Start year counting from 1900.
8                StartMonth      char     Start month, 1 - 12.
9                StartDay        char     Start day, 1 - 31.
10               EndTime         int      End time in minutes since midnight.
12               EndYear         char     End year counting from 1900.
13               EndMonth        char     End month, 1 - 12.
14               EndDay          char     End day, 1 - 31.
15               LeadTime        char     Alarm lead time in minutes, 0 - 30.
16               ApptLength      char     Length of appointment text in bytes.
17               NoteLength      int      Length of note text in bytes.
19               ApptText        ASCII    Appointment text - see note 4 below.
19+ApptLength    NoteText        ASCII    Note text where the null character is used as the line terminator - see note 5 below.
--------------------------------------------------------------------------------
Section:
HP 95LX Appointment Book Monthly by Position Data Record:
Byte Offset      Name            Type     Contents

0                RecordType      char     4 (04h)
1                RecordLength    int      Number of bytes in remainder of this data record, see note 1 below.
3                ApptState       char     See note 2 below.
4                WeekOfMonth     char     Week of month, 1 - 5.
5                DayOfWeek       char     Day of week, 1=Sun, ..., 7=Sat.
6                StartTime       swpint   Start time in minutes since midnight.
8                StartYear       char     Start year counting from 1900.
9                StartMonth      char     Start month, 1 - 12.
10               StartDay        char     Start day, 1 - 31.
11               EndTime         int      End time in minutes since midnight.
13               EndYear         char     End year counting from 1900.
14               EndMonth        char     End month, 1 - 12.
15               EndDay          char     End day, 1 - 31.
16               LeadTime        char     Alarm lead time in minutes, 0 - 30.
17               ApptLength      char     Length of appointment text in bytes.
18               NoteLength      int      Length of note text in bytes.
20               ApptText        ASCII    Appointment text - see note 4 below.
20+ApptLength    NoteText        ASCII    Note text where the null character is used as the line terminator - see note 5 below.
--------------------------------------------------------------------------------
Section:
HP 95LX Appointment Book Yearly Data Record:
Byte Offset      Name            Type     Contents

0                RecordType      char     5 (05h)
1                RecordLength    int      Number of bytes in remainder of this data record, see note 1 below.
3                ApptState       char     See note 2 below.
4                MonthOfYear     char     Month of year, 1=Jan, ... 12=Dec.
5                DayOfMonth      char     Day of month, 1 - 31.
6                StartTime       swpint   Start time in minutes since midnight.
8                StartYear       char     Start year counting from 1900.
9                StartMonth      char     Start month, 1 - 12.
10               StartDay        char     Start day, 1 - 31.
11               EndTime         int      End time in minutes since midnight.
13               EndYear         char     End year counting from 1900.
14               EndMonth        char     End month, 1 - 12.
15               EndDay          char     End day, 1 - 31.
16               LeadTime        char     Alarm lead time in minutes, 0 - 30.
17               ApptLength      char     Length of appointment text in bytes.
18               NoteLength      int      Length of note text in bytes.
20               ApptText        ASCII    Appointment text - see note 4 below.
20+ApptLength    NoteText        ASCII    Note text where the null character is used as the line terminator - see note 5 below.
--------------------------------------------------------------------------------
Section:
HP 95LX Appointment Book To Do Data Record:
Byte Offset      Name            Type     Contents

0                RecordType      char     6 (06h)
1                RecordLength    int      Number of bytes in remainder of this data record, see note 1 below.
3                ToDoState       char     See note 3 below.
4                Priority        char     Priority, 1 - 9.
5                StartYear       char     Start year counting from 1900.
6                StartMonth      char     Start month, 1 - 12.
7                StartDay        char     Start day, 1 - 31.
8                CheckOffYear    char     Check off year counting from 1900, 0 indicates not checked off.
9                CheckOffMonth   char     Check off month, 1 - 12, 0 indicates not checked off.
10               CheckOffDay     char     Check off day, 1 - 31, 0 indicates not checked off.
11               ToDoLength      char     Length of to do text in bytes.
12               NoteLength      int      Length of note text in bytes.
14               ToDoText        ASCII    To do text - see note 4 below.
14+ToDoLength    NoteText        ASCII    Note text where the null character is used as the line terminator - see note 5 below.
--------------------------------------------------------------------------------
Section:
HP 95LX Appointment Book End of File Record:
Byte Offset      Name            Type     Contents
0                RecordType      char     50 (32h)
1                RecordLength    int      0 (00h, 00h)
################################################################################
File:
adjuncts.icn
********************************************************************************
Description:
Procedures for gettext and idxtext
********************************************************************************
Additional Notes:
Pretty mundane stuff. Set_OS(), Basename(), Pathname(), Strip(), and a utility for creating index filenames.
################################################################################
File:
adlutils.icn
********************************************************************************
Description:
Procedures to process address lists
********************************************************************************
Additional Notes:
Procedures used by programs that process address lists:

         nextadd()              get next address
         writeadd(add)          write address
         get_country(add)       get country
         get_state(add)         get state (U.S. addresses only)
         get_city(add)          get city (U.S. addresses only)
         get_zipcode(add)       get ZIP code (U.S. addresses only)
         get_lastname(add)      get last name
         get_namepfx(add)       get name prefix
         get_title(add)         get name title
         format_country(s)      format country name
################################################################################
File:
allof.icn
********************************************************************************
Description:
Procedure for conjunction control operation
********************************************************************************
Additional Notes:
allof{expr1,expr2} -- Control operation that performs iterative conjunction.

Iterative conjunction permits a conjunction expression to be built at run time which supports full backtracking among the created terms of the expression.  The computed expression can be of arbitrary length, and is built via an iterative loop in which one term is appended to the expression (as if connected with a "&" operator) per iteration.

Expr1 works like the control expression of "every-do"; it controls iteration by being resumed to produce all of its possible results. The allof{} expression produces the outcome of conjunction of all of the resulting instances of expr2.

For example:

       global c
       ...
       pattern := "ab*"
       "abcdef" ? {
          allof { c := !pattern ,
             if c == "*" then move(0 to *&subject - &pos + 1) else =c
             } & pos(0)
          }

This example will perform a wild card match on "abcdef" against pattern "ab*", where "*" in a pattern matches 0 or more characters. Since pos(0) will fail the first time it is evaluated, the allof{} expression will be resumed just as a conjunction expression would, and backtracking will propagate through all of the instances of expr2; the expression will ultimately succeed (as its conjunctive equivalent would).

Note that, due to the scope of variables in co-expressions, variables shared between expr1 and expr2 must have global scope, hence c in the above example must be global.

The allof{} procedure models Icon's expression evaluation mechanism in that it explicitly performs backtracking. The author of this procedure knows of no way to invoke Icon's built-in goal directed evaluation to perform conjunction of a arbitrary number of computed expressions (suggestions welcome).
################################################################################
File:
allpat.icn
********************************************************************************
Description:
Procedure to produce all n-character patterns of characters
################################################################################
File:
ansi.icn
********************************************************************************
Description:
Procedures for ANSI-based terminal control
********************************************************************************
Additional Notes:
This package of procedures implements a subset of the ANSI terminal control sequences.  The names of the procedures are taken directly from the ANSI names.  If it is necessary to use these routines with non-ANSI devices, link in iolib.icn, and (optionally) iscreen.icn as well.  Use will be made of whatever routines are made available via either of these libraries.  Be careful of naming conflicts if you link in iscreen.icn. It contains procedures like "clear" and "boldface."

        CUB(i)         Moves the cursor left i columns
        CUD(i)         Moves the cursor down i rows
        CUF(i)         Moves the cursor right i columns
        CUP(i,j)       Moves the cursor to row i, column j
        CUU(i)         Moves the cursor up i rows
        ED(i)          Erases screen: i = 0, cursor to end; i = 1, beginning to cursor; i = 2, all (default 2)
        EL(i)          Erases data in cursor row: i = 0, cursor to end; i = 1, beginning to cursor; i = 2, all (default 0)
        SGR(i)         Sets video attributes: 0 = off; 1 = bold; 4 = underscore; 5 = blink; 7 = reverse (default 0)

Note that not all so-called ANSI terminals support every ANSI screen control sequence - not even the limited subset included in this file.

If you plan on using these routines with non-ANSI magic-cookie terminals (e.g. a Wyse-50) then it is strongly recommended that you link in iolib or itlib *and* iscreen (not just iolib or itlib by itself).  The routines WILL WORK with most magic cookie terminals; they just don't always get all the modes displayed (because they are basically too busy erasing the cookies).
********************************************************************************
Detail Description:
For DOS, or any system using ANSI-conformant output devices, there is no need to link any routines in.

For UNIX systems, you may choose to link in itlib or iolib, and (if desired) iscreen as well.  Some of these may be in the IPL.  You can get any that aren't from Richard Goerwitz (goer@sophist.uchicago.edu).
################################################################################
File:
apply.icn
********************************************************************************
Description:
Procedure to apply a list of functions to an argument
********************************************************************************
Additional Notes:
This procedure applies a list of functions to an argument.  An example is

        apply([integer, log], 10)

which is equivalent to integer(log(10)).
################################################################################
File:
argparse.icn
********************************************************************************
Description:
Procedure to parse pseudo-command-line
********************************************************************************
Additional Notes:
argparse(s) parses s as if it were a command line and puts the components in in a list, which is returned.

At present, it does not accept any escape conventions.
################################################################################
File:
array.icn
********************************************************************************
Description:
Procedures for n-dimensional arrays
********************************************************************************
Additional Notes:
create_array([lbs], [ubs], value) creates a n-dimensional array with the specified lower bounds, upper bounds, and with each array element having the specified initial value.

ref_array(A, i1, i2, ...) references the i1-th i2-th ... element of A.
################################################################################
File:
array.icn
********************************************************************************
Description:
Procedures for n-dimensional arrays
********************************************************************************
Additional Notes:
create_array([lbs], [ubs], value) creates a n-dimensional array with the specified lower bounds, upper bounds, and with each array element having the specified initial value.

ref_array(A, i1, i2, ...) references the i1-th i2-th ... element of A.
################################################################################
File:
asciinam.icn
********************************************************************************
Description:
Procedure for ASCII name of unprintable character
********************************************************************************
Additional Notes:
asciiname(s) returns the mnemonic name of the single unprintable ASCII character s.
################################################################################
File:
base64.icn
********************************************************************************
Description:
Procedures for base64 encodings for MIME (RFC 2045)
********************************************************************************
Additional Notes:
base64encode( s1 ) : s2

   returns the base64 encoding of a string s1

base64decode( s1 ) : s2

   returns the base64 decoding of a string s1 fails if s1 isn't base64 encoded

references:  MIME encoding Internet RFC 2045
################################################################################
File:
basename.icn
********************************************************************************
Description:
Procedure to produce base name of file
********************************************************************************
Additional Notes:
This procedure is based on the UNIX basename(1) utility. It strips off any path information and removes the specified suffix, if present.

It should work under UNIX, MS-DOS, and the Macintosh.
################################################################################
File:
binary.icn
********************************************************************************
Description:
Procedures to pack and unpack values
********************************************************************************
Additional Notes:
This is a collection of procedures that support conversion of Icon data elements to and from binary data formats.  The purpose is to facilitate dealing with binary data files.

The procedures can be used individually or via the "control" procedures pack() and unpack().

The individual conversion functions are prefixed by either "pack_" or "unpack_" and are identified in comments by their format character(s). The "pack_" procedures convert from Icon to binary and take a single argument:  the value to be converted.  The "unpack_" procedures convert from binary to Icon and usually take no parameters -- they are executed within a string-scanning context and scan the necessary amount from the &subject string.  Some of the "unpack_" functions take a parameter that specifies the length of the output string.  The individual conversion procedures are minimally commented, but their action is apparent from their procedure names and the documentation of the pack() and unpack() procedures.

The control procedures pack() and unpack() take a format string that controls conversions of several values (similar to the "printf" C library function).  pack() and unpack() are patterned after the Perl (programming language) functions of the same names, and are documented below.

pack(template,value1,...) : packed_binary_string
------------------------------------------------

This procedure packs the "values" into a binary structure, returning the string containing the structure.  The elements of any lists in the "value" parameters are processed individually as if they were "spliced" into the "value" parameter list.  The "template" is a sequence of characters that give the order and type of values, as follows" (using C language terminology):

  a     An ascii string, will be null padded (unstripped for unpack()).
  A     An ascii string, will be space padded (trailing nulls and spaces will be stripped for unpack()).
  b     A bit string, low-to-high order.
  B     A bit string, high-to-low order.
  h     A hexadecimal string, low-nybble-first.
  H     A hexadecimal string, high-nybble-first.
  c     A signed char value.
  C     An unsigned char value.
  s     A signed short value.
  S     An unsigned short value.
  i     A signed int value.
  I     An unsigned int value.
  l     A signed long value.
  L     An unsigned long value.
  n     A short in "network" order (big-endian).
  N     A long in "network" order (big-endian).
  v     A short in "vax" order (little-endian).
  V     A long in "vax" order (little-endian).
  f     A single-precision float in IEEE Motorola format.
  d     A double-precision float in IEEE Motorola format.
  e     An extended-precision float in IEEE Motorola format 80-bit.
  E     An extended-precision float in IEEE Motorola format 96-bit.
  x     Skip forward a byte (null-fill for pack()).
  X     Back up a byte.
  @     Go to absolute position (null-fill if necessary for pack()).
  u     A uu-encoded/decoded string.

Each letter may optionally be followed by a number which gives a count.  Together the letter and the count make a field specifier. Letters and numbers can be separated by white space which will be ignored.  Types A, a, B, b, H, and h consume one value from the "value" list and produce a string of the length given as the field-specifier-count.  The other types consume "field-specifier-count" values from the "value" list and append the appropriate data to the packed string.

unpack(template,string) : value_list
------------------------------------

This procedure does the reverse of pack():  it takes a string representing a structure and expands it out into a list of values. The template has mostly the same format as for pack() -- see pack(), above.

Endianicity of integers
-----------------------

Integer values can be packed and unpacked in either big-endian (Motorola) or little-endian (Intel) order.  The default is big-endian. Procedures pack_little_endian() and pack_big_endian() set the mode for future packs and unpacks.

Size of ints
------------

The "i" (signed int) and "I" (unsigned int) types can pack and unpack either 16-bit or 32-bit values.  32-bit is the default.  Procedures pack_int_as_short() and pack_int_as_long() change the mode for future packs and unpacks.

To Do List

 - implement other-endian versions of floats (only big-endian supported now).

Procedures for converting real values from input streams. These procedures accept standard IEEE floating point values as strings, usually as read from a file, and return their numeric equivalent as a "real".  The degree of accuracy is likely to vary with different implementations of Icon.

Requires large integers.

Parameter                       Float       Double      Extended    Extended96
=================================================================
Size (bytes:bits)               4:32        8:64        10:80       12:96

Range of binary exponents
  Minimum                      -126        -1022       -16383      -16383
  Maximum                      +127        +1023       +16383      +16383
  Exponent width in bits        8           11          15          15
  Exponent bias                +127        +1023       +16383      +16383

Significand precision
  Bits                          24          53          64          64
  Decimal digits                7-8         15-16       18-19       18-19

Decimal range approximate
  Maximum positive              3.4E+38     1.7E+308    1.1E+4932
  Minimum positive norm         1.2E-38     2.3E-308    1.7E-4932
  Minimum positive denorm       1.5E-45     5.0E-324    1.9E-4951
  Maximum negative denorm      -1.5E-45    -5.0E-324   -1.9E-4951
  Maximum negative norm        -1.2E-38    -2.3E-308   -1.7E-4932
  Minimum negative             -3.4E+38    -1.7E+308   -1.1E+4932
################################################################################
File:
bincvt.icn
********************************************************************************
Description:
Procedures to convert binary data
********************************************************************************
Additional Notes:
unsigned() -- Converts binary byte string into unsigned integer. Detects overflow if number is too large.

This procedure is normally used for processing of binary data read from a file.

raw() -- Puts raw bits of characters of string s into an integer. If the size of s is less than the size of an integer, the bytes are put into the low order part of the integer, with the remaining high order bytes filled with zero.  If the string is too large, the most significant bytes will be lost -- no overflow detection.

This procedure is normally used for processing of binary data read from a file.

rawstring() -- Creates a string consisting of the raw bits in the low order "size" bytes of integer i.

This procedure is normally used for processing of binary data to be written to a file.
################################################################################
File:
binop.icn
********************************************************************************
Description:
Procedure to apply binary operation to list of values
********************************************************************************
Additional Notes:
This procedure applies a binary operation to a list of arguments.

For example,

       binop("+", 1, 2, 3)

returns 6.
################################################################################
File:
bitint.icn
********************************************************************************
Description:
Procedures to convert integers and bit strings
********************************************************************************
Additional Notes:
int2bit(i) produces a string with the bit representation of i.

bit2int(s) produces an integer corresponding to the bit representation i.
################################################################################
File:
bitstr.icn
********************************************************************************
Description:
Procedures for bits in Icon strings
********************************************************************************
Additional Notes:
Procedures for working with strings made up of numeric values represented by strings of an arbitrary number of bits, stored without regard to character boundaries.

In conjunction with the "large integers" feature of Icon, this facility can deal with bitstring segments of arbitrary size.  If "large integers" are not supported, bitstring segments (i.e.  the nbits parameter of BitStringGet and BitStringPut) wider that the integer size of the platform are likely to produce incorrect results.
********************************************************************************
Detail Description:
--------------------------------------------------------------------------------
Section:
Usage of BitStringPut, by example:

       record bit_value(value, nbits)
       ...
       bitString := BitString("")
       while value := get_new_value() do
               BitStringPut(bitString, value.nbits, value.value)
       resultString := BitStringPut(bitString) # output any buffered bits

Note the interesting effect that BitStringPut(bitString), as well as producing the complete string, pads the buffered string to an even character boundary.  This can be dune during construction of a bit string if the effect is desired.

The "value" argument defaults to zero.
--------------------------------------------------------------------------------
Section:
Usage of BitStringGet, by example:

       record bit_value(value, nbits)
       ...
       bitString := BitString(string_of_bits)
       while value := BitStringGet(bitString, nbits) do
               # do something with value

BitStringGet fails when too few bits remain to satisfy a request. However, if bits remain in the string, subsequent calls with fewer bits requested may succeed.  A negative "nbits" value gets the value of the entire remainder of the string, to the byte boundary at its end.

See also: bitstrm.icn
################################################################################
File:     bitstrm.icn
********************************************************************************
Description:
Procedures to read and write strings of bits in files
********************************************************************************
Additional Notes:
Procedures for reading and writing integer values made up of an arbitrary number of bits, stored without regard to character boundaries.
********************************************************************************
Detail Description:
--------------------------------------------------------------------------------
Section:
Usage of BitStreamWrite, by example:

       record bit_value(value, nbits)
       ...
       BitStreamWrite()                        #initialize
       while value := get_new_value() do       # loop to output values
               BitStreamWrite(outfile, value.nbits, value.value)
       BitStreamWrite(outfile)                 # output any buffered bits

Note the interesting effect that BitStreamWrite(outproc), as well asoutputting the complete string, pads the output to an even character boundary.  This can be dune during construction of a bit string if the effect is desired.

The "value" argument defaults to zero.
--------------------------------------------------------------------------------
Section:
Usage of BitStreamRead, by example:

       BitStreamRead()
       while value := BitStreamRead(infile, nbits) do
               # do something with value

BitStringRead fails when too few bits remain to satisfy a request.

See also: bitstr.icn
################################################################################
File:
bkutil.icn
********************************************************************************
Description:
Procedures for HP95LX phone books and appointment books
********************************************************************************
Additional Notes:
Utility procedures for HP95LX phone book and appointment book processing.

See also: abkform.icn, pbkform.icn
################################################################################
File:
bold.icn
********************************************************************************
Description:
Procedures to enbolden and underscore text
********************************************************************************
Additional Notes:
These procedures produce text with interspersed characters suitable for printing to produce the effect of boldface (by over-striking) and underscoring (using backspaces).

       bold(s)        bold version of s

       uscore(s)      underscored version of s
################################################################################
File:
bufread.icn
********************************************************************************
Description:
Procedures for buffered read and lookahead
********************************************************************************
Additional Notes:
Synopsis:

       bufopen(s)      Open a file name s for buffered read and lookahead
       bufread(f)      Read the next line from file f
       bufnext(f, n)   Return the next nth record from file f without changing the next record to be read by bufread
       bufclose(f)     Close file f

These procedures provide a mechanism for looking ahead an arbitrary number of records in an open file while still keeping track of the logical current record and end-of-file. Although similar in intent to the procedures in buffer.icn, these procedures are used differently.  The procedures bufopen, bufread, and bufclose were designed to closely mirror the built-in open, read, and close.

A code segment like

           file := open("name", "r") | stop("open failed")
           while line := read(file) do {
               ...process current line...
           }
           close(file)

can be changed to the following with no difference in behavior:

           file := bufopen("name", "r") | stop("open failed")
           while line := bufread(file) do {
               ...process current line...
           }
           bufclose(file)

However in addition to processing the current line, one may also process subsequent lines BEFORE they are logically read:

           file := bufopen("name", "r") | stop("open failed")
           while line := bufread(file) do {
               ...process current line...
               line := bufnext(file,1) # return next line
               ...process next line...
               line := bufnext(file,2) # return 2nd next line
               ...process 2nd next line...
               ...etc...
           }
           bufclose(file)

In the code above, calls to bufnext do not affect the results of subsequent bufread's.  The bufread procedure always steps through the input file a line at a time without skipping lines whether or not bufnext is called.
********************************************************************************
Detail Description:
--------------------------------------------------------------------------------
Section:
bufopen(s)

Produces a file resulting from opening s for reading ("r" option), but fails if the file cannot be opened.  if s is missing or the value of s is &null, then standard input is opened and &input is returned.  Unlike the Icon open function, bufopen() can and must be called prior to any call to bufread or bufnext involving standard input.  Unlike named files, only one buffered standard input may be open at any given time.

Default:
   s   &null   (indicates &input should be opened for buffered reading)

Errors (from open):
   103     s not string

Errors (new):
   Attempt to open standard input when currently open
--------------------------------------------------------------------------------
Section:
bufread(f)

Produces a string consisting of the next line from f, but fails on end of file. Calls to bufnext do not affect the results of subsequent bufread's. The procedure bufread always steps through a file a line at a time without skipping lines. The procedure bufread fails when a logical end of file is reached, i.e., when the physical end of file has been reached AND the internal buffer is empty.

Default:
   f   &input

Errors:
   f is not a file
   f not opened for buffered reads (includes &input)
--------------------------------------------------------------------------------
Section:
bufnext(f, n)

Produces a string consisting of the nth next line from f after the current line. It fails when the physical end of file has been reached.

Default:
   f   &input
   n   1 (the next line after the current one)

Errors:
   f is not a file
   f not opened for buffered reads (includes &input)
   n not convertible to integer
   n not positive
--------------------------------------------------------------------------------
Section:
bufclose(f)

Produces f after closing it.  Standard input must be closed before it can be reopened using bufopen. If standard input is closed, all lines read using bufnext are lost when it is reopened. In general, there is no practical reason to bufclose and then bufopen standard input. One may want to bufclose standard input to release its internal buffer for garbage collection.

Default:
   f   &input

Errors (from close):
   105     f not file
################################################################################
File:
calendar.icn
********************************************************************************
Description:
Procedures for data and time calculation and conversion
********************************************************************************
Additional Notes:
Procedures in this file supercede several procedures in datetime.icn.
********************************************************************************
Detail Description:
--------------------------------------------------------------------------------
Section:
Setting up

You will probably want to set a platform environment variable "Cal_TimeZone" to an appropriate local time zone ID string before using this library. Look at the time zone data at the end of this source file and choose an ID for your locale. Common ones for USA are "PST", "MST", "CST", and "EST", although there are more specific ones such as "America/Arizona" that handle special rules. If environment variables are not supported for your platform or your implementation of Icon, explicitly specify the default time zone in your program: e.g.

       Cal_CurrentTimeZone := Cal_GetTimeZone("PST").

If your system uses a base year for date calculation that is different from 1970, your can specify it in an environment variable "Cal_DateBaseYear" or set it directly in the global variable by the same name. Unix and Windows use the library's default value of 1970, but Macintosh used to use 1984 (I'm not sure if Apple have yet seen fit to conform to the 1970 quasi-standard). This setting doesn't matter unless you want your "seconds" values to be the same as your system's.
--------------------------------------------------------------------------------
Section:
GMT and local time

GMT (Greenwich Mean Time) is a universal time standard (virtually equivalent to "Coordinated Universal Time" (UTC), except for some millisecond differences).
--------------------------------------------------------------------------------
Section:
Time forms

There are two fundamental date/time forms supported by this library: a form in which computation is easy (the "seconds" form) and a form in which formatting is easy (the "calendar record" form).

    - Seconds -- the time is be represented as an integer that is the number of seconds relative to the beginning of Cal_DateBaseYear, GMT. Cal_DateBaseYear is usually 1970, but can be changed). The "seconds" form is a universal time, independent of locale.

    - Cal_Rec -- a "calendar record", which has fields for date and time components: year, month, day, hour, minutes, seconds and day-of-week. The "Cal_Rec" form is usually in terms of local time, including accounting for daylight savings time according to local rules.
--------------------------------------------------------------------------------
Section:
Notes

    - Several procedures have a final "timeZone" parameter. In those procedures the timeZone parameter is optional and, if omitted, Cal_CurrentTimeZone is used.

    - The time zone table and list consume around 30KB that can be "freed" by setting both Cal_TimeZoneTable and Cal_TimeZoneList to &null. Procedures Cal_GetTimeZoneTable() and Cal_GetTimeZoneList() will re-create the structures and assign them back to their globals. For many applications, those structures are no longer needed after program initialization.

    - The global variables are automatically initialized by the Cal_ procedures. However, if you want to use the globals before using any procedures, they must be explicitly initialized by calling Cal_Init().

    - Time zone records in the time zone structures should be viewed as read-only. If you want to make temporary changes to the fields, copy() the time zone record.
--------------------------------------------------------------------------------
Section:
Global variables

The following global variables are useful in date and time operations (R/O means please don't change it):

    - Cal_SecPerMin	- (R/O) Seconds per minute.
    - Cal_SecPerHour	- (R/O) Seconds per hour.
    - Cal_SecPerDay	- (R/O) Seconds per day.
    - Cal_SecPerWeek	- (R/O) Seconds per week.
    - Cal_MonthNames	- (R/O) List of month names.
    - Cal_DayNames	- (R/O) List of day names.
    - Cal_CurrentTimeZone	- Current default time zone record -- can be changed at any time. Initialized to the time zone whose ID is in environment variable "Cal_TimeZone" if set, or to GMT.
    - Cal_TimeZoneGMT	- (R/O) The GMT time zone record. Can be used as a timeZone parameter to "turn off" conversion to or from local.
    - Cal_DateBaseYear - The base year from which the "seconds" form is calculated, initialized to the value of environment variable "Cal_DateBaseYear" if set, or 1970 (the year used by both Unix and MS-Windows)
    - Cal_TimeZoneTable - A table of time zones keyed by the time zone's ID string
    - Cal_TimeZoneList - A list of time zones ordered by increasing offset from GMT
--------------------------------------------------------------------------------
Section:
Initialization procedure

    Cal_Init()
        Initializes global variables. Called implicitly by the Cal_ procedures.
--------------------------------------------------------------------------------
Section:
Cal_Rec (calendar record) procedures

    Cal_Rec(year,month,day,hour,min,sec,weekday)
        Cal_Rec record constructor. All values are integers in customary US usage (months are 1-12, weekdays are 1-7 with 1 -> Sunday)

    Cal_SecToRec(seconds,timeZone)
        Converts seconds to a Cal_Rec, applying conversion rules of "timeZone". To suppress conversion, specify timeZone = Cal_TimeZoneGMT.

    Cal_RecToSec(calRec,timeZone)
        Converts a Cal_Rec to seconds, applying conversion rules of "timeZone". To suppress conversion, specify timeZone = Cal_TimeZoneGMT.
--------------------------------------------------------------------------------
Section:
Time zone procedures

    Cal_GetTimeZone(timeZoneName)
        Gets a time zone given a time zone ID string. Fails if a time zone for the given ID cannot be produced.

    Cal_GetTimeZoneList()
        Returns the tine zone list that is the value of Cal_TimeZoneList, unless that global has been explicitly set to &null. If the global is null, a new list is built, assigned to Cal_TimeZoneList, and returned.

    Cal_GetTimeZoneTable()
        Returns the tine zone table that is the value of Cal_TimeZoneTable, unless that global has been explicitly set to &null. If the global is null, a new table is built, assigned to Cal_TimeZoneTable, and returned. In building the table, Cal_GetTimeZoneList() is called so global variable Cal_TimeZoneList is also set.
--------------------------------------------------------------------------------
Section:
Date/time calculation procedures

    Cal_LocalToGMTSec(seconds,timeZone)
        Converts seconds from local to GMT using the rules of timeZone.

    Cal_GMTToLocalSec(seconds,timeZone)
        Converts seconds from GMT to local using the rules of timeZone.

    Cal_IsLeapYear(year)
        Returns the number of seconds in a day if year is a leap year, otherwise fails.

    Cal_LeapYearsBetween(loYear,hiYear)
        Returns the count of leap years in the range of years n where loYear <= n < hiYear.

    Cal_IsDST(seconds,timeZone)
        Returns the DST offset in hours if seconds (local time) is in the DST period, otherwise fails.

    Cal_NthWeekdayToSec(year,month,weekday,n,fromDay)
        Returns seconds of nth specified weekday of month, or fails if no such day. This is mainly an internal procedure for DST calculations, but might have other application.
--------------------------------------------------------------------------------
Section:
Date/time formatting procedures

    Cal_DateLineToSec(dateline,timeZone)
        Converts a date in something like Icon's &dateline format (Wednesday, February 11, 1998  12:00 am) to "seconds" form.

    Cal_DateToSec(date,timeZone)
        Converts a date string in something like Icon &date format (1998/02/11) to "seconds" form.

    Cal_SecToDate(seconds,timeZone)
        Converts "seconds" form to a string in Icon's &date format (1998/02/11).

    Cal_SecToDateLine(seconds,timeZone)
        Converts "seconds" form to a string in Icon's &dateline format (Wednesday, February 11, 1998  12:00 am).

    Cal_SecToUnixDate(seconds,timeZone)
        Converts "seconds" form to a string in typical UNIX date/time format (Jan 14 10:24 1991).
--------------------------------------------------------------------------------
Section:
Time-only formatting procedures

    Cal_ClockToSec(seconds)
        Converts a time in the format of &clock (19:34:56) to seconds past midnight.

    Cal_SecToClock(seconds)
        Converts seconds past midnight to a string in the format of &clock (19:34:56).

See also:  datetime.icn, datefns.icn
################################################################################
File:
calendat.icn
********************************************************************************
Description:
Procedure to get date from Julian Day Number
********************************************************************************
Additional Notes:
calendat(j) return a record with the month, day, and year corresponding to the Julian Date Number j.

As the former contents of this file were a direct extract from the IPL file datetime.icn, replace the code with a link to datetime.

record date1(month, day, year)
procedure calendat(julian)

Acknowledgement:  This procedure is based on an algorithm given in "Numerical Recipes; The Art of Scientific Computing"; William H. Press, Brian P. Flannery, Saul A. Teukolsky. and William T. Vetterling; Cambrdayge University Press, 1986.
################################################################################
File:
calls.icn
********************************************************************************
Description:
Procedures for calls as objects
********************************************************************************
Additional Notes:
These procedures deal with procedure invocations that are encapulated in records.
################################################################################
File:
capture.icn
********************************************************************************
Description:
Procedures to echo output to a second file
********************************************************************************
Additional Notes:
Capture is initially called by the user with one argument, the open file  to contain the echoed output. Then it places itself and several shadow  procedures between all calls to write, writes & stop.  The user never need call capture again.

Subsequently, during calls to write, writes, and stop, the approprate shadow procedure gains control and calls capture internally. Capture then constructs a list of only those elements that direct output to &output and calls the original builtin function via the saved name. Upon return the shadow routine calls the the original builtin function  with the full list.

A series of uncaptured output functions have been added to allow output to be directed only to &output.  These are handy for placing progress messages and other comforting information on the screen.
********************************************************************************
Detail Description:
--------------------------------------------------------------------------------
Section:
Example:

     otherfile := open(...,"w")

     capfile :=  capture(open(filename,"w"))

     write("Hello there.",var1,var2," - this should be echoed",
        otherfile,"This should appear once in the other file only")

     uncaptured_writes("This will appear once only.")

     every i := 1 to 10000 do
        if ( i % 100 ) = 0 then

           uncaptured_writes("Progress is ",i,"\r")

     close(capfile)
     close(otherfile)
--------------------------------------------------------------------------------
Section:
Notes:

  1.    stop must be handled specially in its shadow function
  2.    capture is not designed to be turned off
  3.    This may be most useful in systems other than Unix (i.e. that don't have a "tee" command)
  4.    Display has not been captured because
        a) display is usually a debugging aid, and capture was originally intended to capture screen output to a file where a record or audit trail might be required
        b) the display output would be 'down a level' showing the locals at the display_capture_ level, although the depth argument could easily be incremented to adjust for this
        c) write, writes, and stop handle arguments the same way
  5.    An alternative to having two calls would be to have capture call the desired procedure with :
           push(&output,x) ; return p!(y ||| x )
        While this would remove the complexity with stop it would probably be slower
################################################################################
File:
cartog.icn
********************************************************************************
Description:
Procedures for cartographic projection
********************************************************************************
Additional Notes:
These procedures project geographic coordinates.

rectp(x1, y1, x2, y2, xm, ym) defines a rectangular projection.

pptrans(L1, L2) defines a planar projective transformation.

utm(a, f) defines a latitude/longitude to UTM projection.


project(p, L) projects a list of coordinates.

invp(p) returns the inverse of projection p.

compose(p1, p2, ...) creates a composite projection.
********************************************************************************
Detail Description:
--------------------------------------------------------------------------------
Section:
rectp(x1, y1, x2, y2, xm, ym)
returns a rectangular projection in which the point (x1, y1) maps to (x2, y2). If xm is specified, distances in the projected coordinate system are scaled by xm. If ym is also specifed, xm scales x values while ym scales y values.
--------------------------------------------------------------------------------
Section:
pptrans(L1, L2)
returns a planar projective transform that maps the four points in L1 to the four points in L2. Each of the two lists contains 8 coordinates: [x1, y1, x2, y2, x3, y3, x4, y4].
--------------------------------------------------------------------------------
Section:
utm(a, f)
returns a projection from latitude and longitude to Universal Transverse Mercator (UTM) representation. The reference ellipsoid is specified by a, the equatorial radius in metres, and f, the flattening. Alternatively, f can be omitted with a specifying a string, such as "Clarke66"; if a is also omitted, "WGS84" is used. See ellipsoid() in geodat.icn for the list of possible strings.

The input list contains signed numeric values: longitude and latitude, in degrees, in that order (x before y). The output list contains triples: an integer zone number followed by real-valued UTM x and y distances in metres. No "false easting" is applied.
--------------------------------------------------------------------------------
Section:
project(p, L)
applies a projection, reading a list of coordinates and returning a new list of transformed coordinates.
--------------------------------------------------------------------------------
Section:
invp(p)
returns the inverse of projection p, or fails if no inverse projection is available.
--------------------------------------------------------------------------------
Section:
compose(p1, p2, ..., pn)
returns the projection that is thecomposition of the projections p1, p2, ..., pn. The composition applies pn first.
--------------------------------------------------------------------------------
Section:
UTM conversion algorithms are based on:

    Map Projections: A Working Manual
    John P. Snyder
    U.S. Geological Survey Professional Paper 1395
    Washington: Superintendent of Documents, 1987

--------------------------------------------------------------------------------
Section:
Planar projective transformation calculations come from:

    Computing Plane Projective Transformations (Method 1)
    Andrew Zisserman, Robotics Research Group, Oxford
    in CVOnline (R. Fisher, ed.), found 22 February 2000 at:
    http://www.dai.ed.ac.uk/CVonline/LOCAL_COPIES/EPSRC_SSAZ/node11.html
################################################################################
File:
caseless.icn
********************************************************************************
Description:
Procedures to perform caseless scanning
********************************************************************************
Additional Notes:
These procedures are analogous to the standard string-analysis functions except that uppercase letters are considered equivalent to lowercase letters.

anycl(c, s, i1, i2)             succeeds and produces i1 + 1, provided map(s[i1]) is in cset(map(c)) and i2 is greater than i1.  It fails otherwise.

balcl(c1, c2, c3, s, i1, i2)    generates the sequence of integer positions in s preceding a character of cset(map(c1)) in map(s[i1:i2]) that is balanced with respect to characters in cset(map(c2)) and cset(map(c3)), but fails if there is no such position.

findcl(s1, s2, i1, i2)          generates the sequence of integer positions in s2 at which map(s1) occurs as a substring in map(s2[i1:i2]), but fails if there is no such position.

manycl(c, s, i1, i2)            succeeds and produces the position in s after the longest initial sequence of characters in cset(map(c)) within map(s[i1:i2]).  It fails if map(s[i1]) is not in cset(map(c)).

matchcl(s1, s2, i1, i2)         produces i1 + *s1 if map(s1) == map(s2[i1+:=*s1]) but fails otherwise.

uptocl(c, s, i1, i2)            generates the sequence of integer positions in s preceding a character of cset(map(c)) in map(s[i1:i2]).  It fails if there is no such position.

Defaults:
                s, s2       &subject
                i1          &pos if s or s2 is defaulted; otherwise 1
                i2          0
                c1          &cset
                c2          '('
                c3          ')'

Errors:
                101         i1 or i2 not integer
                103         s or s1 or s2 not string
                104         c or c1 or c2 or c3 not cset
################################################################################
File:
codeobj.icn
********************************************************************************
Description:
Procedures to encode and decode Icon data
********************************************************************************
Additional Notes:
These procedures provide a way of storing Icon values as strings and retrieving them.  The procedure encode(x) converts x to a string s that can be converted back to x by decode(s). These procedures handle all kinds of values, including structures of arbitrary complexity and even loops.  For "scalar" types -- null, integer, real, cset, and string --

    decode(encode(x)) === x

For structures types -- list, set, table, and record types -- decode(encode(x)) is, for course, not identical to x, but it has the same "shape" and its elements bear the same relation to the original as if they were encoded and decode individually.

No much can be done with files, functions and procedures, and co-expressions except to preserve type and identification.

The encoding of strings and csets handles all characters in a way that it is safe to write the encoding to a file and read it back.

No particular effort was made to use an encoding of value that minimizes the length of the resulting string. Note, however, that as of Version 7 of Icon, there are no limits on the length of strings that can be written out or read in.
********************************************************************************
Detail Description:
The encoding of a value consists of four parts:  a tag, a length, a type code, and a string of the specified length that encodes the value itself.

The tag is omitted for scalar values that are self-defining. For other values, the tag serves as a unique identification. If such a value appears more than once, only its tag appears after the first encoding. There is, therefore, a type code that distinguishes a label for a previously encoded value from other encodings. Tags are strings of lowercase letters. Since the tag is followed by a digit that starts the length, the two can be distinguished.

The length is simply the length of the encoded value that follows.

The type codes consist of single letters taken from the first character of the type name, with lower- and uppercase used to avoid ambiguities.

Where a structure contains several elements, the encodings of the elements are concatenated. Note that the form of the encoding contains the information needed to separate consecutive elements.

Here are some examples of values and their encodings:

    x                     encode(x)
   -------------------------------------------------------

    1                     "1i1"
    2.0                   "3r2.0"
    &null                 "0n"
    "\377"                "4s\\377"
    '\376\377'            "8c\\376\\377"
    procedure main        "a4pmain"
    co-expression #1 (0)  "b0C"
    []                    "c0L"
    set()                 "d0S"
    table("a")            "e3T1sa"
    L1 := ["hi","there"]  "f11L2shi5sthere"

A loop is illsutrated by

    L2 := []
    put(L2,L2)

for which

    x                     encode(x)
   -------------------------------------------------------

    L2                    "g3L1lg"

Of course, you don't have to know all this to use encode and decode.
################################################################################
File:
colmize.icn
********************************************************************************
Description:
Procedure to arrange data into columns
********************************************************************************
Additional Notes:
colmize() -- Arrange data into columns.

Procedure to arrange a number of data items into multiple columns. Items are arranged in column-wise order, that is, the sequence runs down the first column, then down the second, etc.

This procedure goes to great lengths to print the items in as few vertical lines as possible.
################################################################################
File:
colrspec.icn
********************************************************************************
Description:
Procedure to produce VRML color specifications
################################################################################
File:
complete.icn
********************************************************************************
Description:
Procedure to complete partial input string
********************************************************************************
Additional Notes:
complete(s,st)      completes a s relative to a set or list of strings, st. Put differently, complete() lets you supply a partial string, s, and get back those strings in st that s is either equal to or a	substring of.
********************************************************************************
Detail Description:
Lots of command interfaces allow completion of partial input. Complete() simply represents my personal sentiments about how this might best be done in Icon.  If you strip away the profuse comments below, you end up with only about thirty lines of actual source code.

I have arranged things so that only that portion of an automaton which is needed to complete a given string is actually created and stored. Storing automata for later use naturally makes complete() eat up more memory. The performance gains can make it worth the trouble, though.  If, for some reason, there comes a time when it is advisable to reclaim the space occupied by complete's static structures, you can just call it without arguments. This "resets" complete() and forces an immediate garbage collection.
--------------------------------------------------------------------------------
Section:
Example code:

        commands := ["run","stop","quit","save","load","continue"]
        while line := read(&input) do {
           cmds := list()
           every put(cmds, complete(line, commands))
           case *cmds of {
               0 : input_error(line)
               1 : do_command(cmds[1])
               default : display_possible_completions(cmds)
           }
           etc...

More Iconish methods might include displaying successive alternatives each time the user presses the tab key (this would, however, require using the nonportable getch() routine). Another method might be to use the first string suspended by complete().
--------------------------------------------------------------------------------
Section:
NOTE:
This entire shebang could be replaced with a slightly slower and much smaller program suggested to me by Jerry Nowlin and Bob Alexander.

       procedure terscompl(s, st)
           suspend match(s, p := !st) & p
       end

This program will work fine for lists with just a few members, and also for cases where s is fairly large. It will also use much less memory.
################################################################################
File:
complex.icn
********************************************************************************
Description:
Procedures to perform complex arithmetic
********************************************************************************
Additional Notes:
The following procedures perform operations on complex numbers.

        complex(r,i)        create complex number with real part r and imaginary part i

        cpxadd(z1, z2)      add complex numbers z1 and z2

        cpxdiv(z1, z2)      divide complex number z1 by complex number z2

        cpxmul(z1, z2)      multiply complex number z1 by complex number z2

        cpxsub(z1, z2)      subtract complex number z2 from complex number z1

        cpxstr(z)           convert complex number z to string representation

        strcpx(s)           convert string representation s of complex number to complex number
################################################################################
File:
conffile.icn
********************************************************************************
Description:
Procedures to read initialization directives
********************************************************************************
Additional Notes:
At Some point certain procedures become indispensable.  Anyone who has used 'options' from the Icon program library will probably agree. I found a need to be able to quickly, change the format and interpretation of a set of configuration and rules files. And so, I hope this collection of procedures will become similarly indispensable.

    Directive( p1, p2, i1, i2 ) : r1

        returns a specification record for a table required by ReadDirectives

        p1 is the build procedure used to extract the data from the file. The table below describes the build procedures and the default minimum and maximum number of arguments for each. If the included procedures don't meet your needs then you can easily add your own and still use Directive to build the specification.

                build procedure           |  minargs  |  maxargs
                --------------------------|-----------|---------
                Directive_table_of_sets   |     2     |      -
                Directive_table           |     2     |      -
                Directive_value           |     1     |      1
                Directive_set             |     1     |      -
                Directive_list            |     1     |      -
                < user defined >          |     1     |      -
                Directive_exists          |     0     |      0
                Directive_ignore          |     0     |      -
                Directive_warning         |     0     |      -

        p2 is an edit procedure that allows you to preprocess the data or null
        i1 is the minimum number of arguments for this directive, default is 1
        i2 is the maximum number of arguments for this directive

    Run-time Errors:
        - 123 if p1 isn't a procedure
        - 123 if p2 isn't null or a procedure
        - 101 if i1, i2 aren't integers and not ( 0 <= i1 <= i2 ) after defaults

    ReadDirectives( l1, t1, s1, s2, c1, c2, p1 ) : t2

        returns a table containing parsed directives for the specified file

        l1 is a list of file names or open files, each element of l1 is tried in turn until a file is opened or an open file is encountered.

            For example: [ "my/rules", "/etc/rules", &input ]

        t1 is a table of specifications for parsing and handling each directive
        s1 the comment character, default "#"
        s2 the continuation character, default "_"
        c1 the escape character, default "\"
        c2 the cset of whitespace, default ' \b\t\v\f\r'
        p1 stop | an error procedure to be called, fail if null

        t2 is a table containing the parsed results keyed by tag

    Notes:
        - the special key "*file*" is a list containing the original text of input file with interspersed diagnostic messages.
        - the comment, escape, continuation and whitespace characters must not overlap (unpredictable)
        - the end of a directive statement will forcibly close an open quote (no warning)
        - the end of file will forcibly close a continuation (no warning)

    Run-time Errors:
        - 103, 104, 107, 108, 500
            500 errors occur if:
                - arguments are too big/small
                - the specification table is improper
********************************************************************************
Detail Description:
--------------------------------------------------------------------------------
Section:
Directive file syntax:

        - blank lines are ignored
        - all syntactic characters are parameterized
        - everything after a comment character is ignored (discarded)
        - to include a comment character in the directive, precede it with an escape
        - to continue a directive, place a continue character at the end of the line (before comments)
        - trailing whitespace is NOT ignored in continuations
        - quoted strings are supported,
        - to include a quote within a quoted string, precede the enclosed quote with an escape
--------------------------------------------------------------------------------
Section:
Usage:

    -- Config file, example: --

        # comment line

        var1 "This string, w/o quotes, will be in cfgspec[\"var\"]"
        cset1 "abcdefffffffffffff"   # type of quotes isn't important
        int1  12345
        lcase1 "Hello There THIs iS CasE inSENsITive"
        list1 one two three _ # continues
            four five one three zero
        set1 one one one two three 3 'a b c' # one two three 3 'a b c'
        table1 k1 v1
        table1 k2 v2
        t/set1 key1 v1 v2 v3 v4
        t/set1 key2 v5 v6
        t/set1 key3 "1 2 \#3"  # comment
        warn1  this will produce _
            a warning
--------------------------------------------------------------------------------
Section:
    -- Coding example: --

        # 1. Define a specification table using Directive.
        #    Directive has four fields:
        #    - the procedure to handle the tag
        #    - an optional edit procedure to preprocess the data
        #    - the minimum number of values following the tag,
        #      default is dependant on the &null is treated as 0
        #    - the maximum number of values following the tag,
        #      &null is treated as unlimited
        #    The table's keys are the directives of the configuration file
        #    The default specification should be either warning of ignore

            cfgspec    := table( Directive( Directive_warning ) )
            cfgspec["var1"]   := Directive( Directive_value )
            cfgspec["cset1"]  := Directive( Directive_value, cset )
            cfgspec["int1"]   := Directive( Directive_value, integer )
            cfgspec["lcase1"] := Directive( Directive_value, map )
            cfgspec["list1"]  := Directive( Directive_list )
            cfgspec["set1"]   := Directive( Directive_set )
            cfgspec["table1"] := Directive( Directive_table )
            cfgspec["t/set1"] := Directive( Directive_table_of_sets )

        # 2. Read, parse and build a table based upon the spec and the file

            cfg := ReadDirectives( ["my.conf",&input], cfgspec )

        # 3. Process the output

            write("Input:\n")
            every write(!cfg["*file*"])
            write("\nBuilt:\n")
            every  k :=key(cfg) do
            if k ~== "*file*" then write(k, " := ",ximage(cfg[k]))
--------------------------------------------------------------------------------
Section:
    -- Output: --

        Input:

        # comment line

        var1 "This string, w/o quotes, will be in cfgspec[\"var\"]"
        cset1 "abcdefffffffffffff"   # type of quotes isn't important
        int1  12345
        lcase1 "Hello There THIs iS CasE inSENsITive"
        list1 one two three _ # continues
            four five one three zero
        set1 one one one two three 3 'a b c' # one two three 3 'a b c'
            table1 k1 v1
            table1 k2 v2
            t/set1 key1 v1 v2 v3 v4
            t/set1 key2 v5 v6
            t/set1 key3 "1 2 \#3"  # comment
        warn This will produce a _
            warning
        -- Directive isn't defined in specification.

        Built:

        set1 := S1 := set()
            insert(S1,"3")
            insert(S1,"a b c")
            insert(S1,"one")
            insert(S1,"three")
            insert(S1,"two")
        cset1 := 'abcdef'
        t/set1 := T4 := table(&null)
            T4["key1"] := S2 := set()
                insert(S2,"v1")
                insert(S2,"v2")
                insert(S2,"v3")
                insert(S2,"v4")
            T4["key2"] := S3 := set()
                insert(S3,"v5")
                insert(S3,"v6")
            T4["key3"] := S4 := set()
                insert(S4,"1 2 #3")
        list1 := L12 := list(8)
            L12[1] := "one"
            L12[2] := "two"
            L12[3] := "three"
            L12[4] := "four"
            L12[5] := "five"
            L12[6] := "one"
            L12[7] := "three"
            L12[8] := "zero"
        lcase1 := "hello there this is case insensitive"
        int1 := 12345
        var1 := "This string, w/o quotes, will be in cfgspec[\"var\"]"
        table1 := T3 := table(&null)
            T3["k1"] := "v1"
            T3["k2"] := "v2"
################################################################################
File:
converge.icn
********************************************************************************
Description:
Procedure to produce continued-fraction convergents
********************************************************************************
Additional Notes:
This procedure produces continued-fraction convergents from a list of partial quotients.
################################################################################
File:
convert.icn
********************************************************************************
Description:
Procedures for various conversions
********************************************************************************
Additional Notes:
    exbase10(i, j)      converts base-10 integer i to base j.

    inbase10(s, i)      convert base-i integer s to base 10.

    radcon(s, i, j)     convert base-i integer s to base j.

There are several other procedures related to conversion that are not yet part of this module.
################################################################################
File:
core.icn
********************************************************************************
Description:
Procedures for general application
********************************************************************************
Additional Notes:
Links to core modules of the basic part of the library, as defined in the Icon Language book (3/e, p.179) and Graphics book (p.47).
################################################################################
File:
created.icn
********************************************************************************
Description:
Procedure to determine number of structures created
********************************************************************************
Additional Notes:
This program returns the number of stuctures of a given type have been created.
################################################################################
File:
currency.icn
********************************************************************************
Description:
Procedures for formatting currency
********************************************************************************
Additional Notes:
currency() -- Formats "amount" in standard American currency format. "amount" can be a real, integer, or numeric string. "width" is the output field width, in which the amount is right adjusted. The returned string will be longer than "width" if necessary to preserve significance. "minus" is the character string to be used for negative amounts (default "-"), and is placed to the right of the amount.
################################################################################
File:
curves.icn
********************************************************************************
Description:
Procedures to generate points on plain curves
********************************************************************************
Additional Notes:
This file links procedure files that generate traces of points on various plain curves.

The first two parameters determine the defining position of the curve:

    x       x coordinate
    y       y coordinate

The meaning of "definition position" depends on the curve.  In some cases it is the position at which plotting starts.  In others, it is a "center" for the curve.

The next arguments vary and generally refer to parameters of the curve.  There is no practical way to describe these here.  If they are not obvious, the best reference is

    A Catalog of Special Plane Curves, J. Dennis Lawrence, Dover Publications, Inc., New York, 1972.

This book, which is in print at the time of this writing, is a marvelous source of information about plane curves and is inexpensive as well.

The trailing parameters give the number of steps and the end points (generally in angles) of the curves:

    steps   number of points, default varies
    lo      beginning of plotting range, default varies
    hi      end of plotting range, default varies

Because of floating-point roundoff, the number of steps may not be exactly the number specified.

Note:  Some of the curves may be "upside down" when plotted on coordinate systems in which the y axis increases in a downward direction.

Caution:  Some of these procedures generate very large values in portions of their ranges. These may cause run-time errors when used in versions of Icon prior to 8.10. One work-around is to turn on error conversion in such cases.

Warning:  The procedures that follow have not been tested thoroughly. Corrections and additions are most welcome.

These  procedures are, in fact, probably most useful for the parametric equations they contain.
################################################################################
File:
datecomp.icn
********************************************************************************
Description:
Procedures for date comparison
********************************************************************************
Additional Notes:
These procedures do simple date comparisons. The first is a greater than [dgt(date1, date2)] the second is less than [dlt(date1, date2)] the third is equaity [deq(date1, date2)], and the fourth will determine if the date parameter in the future or not [futuredate(date1)] finally, pastdate  will determine if date1 is less than &date [pastdate(date1)] (in the past)

    dgt will succeed if date1 is greater than date2
    dlt will succeed if date1 is less than date2
    deq will succeed if date1 is equal to date2
    futuredate will succeed if date1 is greater than &date
    pastdate will succeed if date1 is less than &date

The format for the parameters are strings of the format mm/dd/yyyy or yyyy/mm/dd (not my favorite, but this will comply with icons format of &date)

NOTE:
    These functions will not work unless they are formatted precicely as stated above (i.e., January first 12 ad needs to be passed as "01/01/0012" or "0012/01/01")

REVISION:
    Added procedure betweendates(date1, date2, date3)
    This function will return 1 if date 1 is between (or equal to) date2 and date3.
    Made all procedures that may need to reformat date call it by default.
    Now, reformatdate will only reformat the date if needed.  Otherwise it will just return what it was passed.

    April 20, 1999
        modified reformatdate to handle dates passed in as yyyymmdd with no '/'
################################################################################
File:
datefns.icn
********************************************************************************
Description:
Procedure for dates
********************************************************************************
Additional Notes:
datefns.icn - a collection of date functions

Taken from various sources as attributed below.

All date and calendar functions use the "date_rec" structure defined below.

Note:  I adapted the procedures "julian" and "unjulian" sometime in 1994 from "Numerical Recipes in C."  Some time later I discovered them (under slightly different names) in Version 9 of the Icon Library (Ralph Griswold, author).  I am including mine for what they are worth. That'll teach me to wait!

The next two routines have been adapted from "Numerical Recipes in C," by Press, Flannery, Teukolsky, and Vetterling (Cambridge, 1988). The following quote is from page 10:

Astronomers number each 24-hour period, starting and ending at noon, with a unique integer, the Julian Day Number. Julian Day Zero was a very long time ago; a convenient reference point is that Julian Day 2440000 began at noon of May 23, 1968.  If you know the Julian Day Number that began at noon of a given calendar date, then the day of the week of that date is obtained by adding 1 and taking the result modulo base 7; a zero answer corresponds to Sunday, 1 to Monday, ..., 6 to Saturday.

The C code presented in that book heavily uses the automatic conversion of real (floating point) numbers to integers by truncation. Since Icon doesn't do this, explicit type conversions are required.

################################################################################
File:
datetime.icn
********************************************************************************
Description:
Procedures for date and time operations
********************************************************************************
Additional Notes:
Notes:
    - the default value for function parameters named "hoursFromGmt" is the value of global variable "HoursFromGmt" if nonnull, or environment variable "HoursFromGmt" if set, or 0.
    - The base year from which the "seconds" representation of a date is calculated is by default 1970 (the ad hoc standard used by both Unix and MS-Windows), but can be changed by either setting the global variable "DateBaseYear" or environment variable "DateBaseYear".
    - There are some procedures not mentioned in this summary that are useful: DateRecToSec(), SecToDateRec(). See the source code for details.

ClockToSec(seconds)
    converts a time in the format of &clock to seconds past midnight.

DateLineToSec(dateline,hoursFromGmt)
    converts a date in &dateline format to seconds since start of dateBaseYear.

DateToSec(date,hoursFromGmt)
    converts a date string in Icon &date format (yyyy/mm/dd) to seconds past DateBaseYear.

SecToClock(seconds)
    converts seconds past midnight to a string in the format of &clock.

SecToDate(seconds,hoursFromGmt)
    converts seconds past DateBaseYear to a string in Icon &date format (yyyy/mm/dd).

SecToDateLine(seconds,hoursFromGmt)
    produces a date in the same format as Icon's &dateline.

SecToUnixDate(seconds,hoursFromGmt)
    returns a date and time in typical UNIX format: Jan 14 10:24 1991.

IsLeapYear(year)
    succeeds if year is a leap year, otherwise fails.

calendat(j)
    returns a record with the month, day, and year corresponding to the Julian Date Number j.

date()
    natural date in English.

dayoweek(day, month, year)
    produces the day of the week for the given date

full13th(year1, year2)
    generates records giving the days on which a full moon occurs on Friday the 13th in the range from year1 though year2.

julian(m, d, y)
    returns the Julian Day Number for the specified month, day, and year.

pom(n, phase)
    returns record with the Julian Day number of fractional part of the day for which the nth such phase since January, 1900.  Phases are encoded as:

        0 - new moon
        1 - first quarter
        2 - full moon
        3 - last quarter#

    GMT is assumed.

saytime()
    computes the time in natural English.  If an argument is supplied it is used as a test value to check the operation the program.

walltime()
    produces the number of seconds since midnight. Beware wrap-around when used in programs that span midnight.

Acknowledgement:  Some of these procedures are based on an algorithm given in "Numerical Recipes; The Art of Scientific Computing"; William H. Press, Brian P. Flannery, Saul A. Teukolsky, and William T. Vetterling;#  Cambridge University Press, 1986.
################################################################################
File:
ddfread.icn
********************************************************************************
Description:
Procedures for reading ISO 8211 DDF files
********************************************************************************
Additional Notes:
These procedures read DDF files ("Data Descriptive Files", ISO standard 8211) such as those specified by the US Geological Survey's "Spatial Data Transfer Standard" for digital maps. ISO8211 files from other sources may contain additional data encodings not recognized by these procedures.

    ddfopen(filename)   opens a file and returns a handle.
    ddfdda(handle)      returns a list of header records.
    ddfread(handle)     reads the next data record.
    ddfclose(handle)    closes the  file.
********************************************************************************
Detail Description:
--------------------------------------------------------------------------------
Section:
ddfopen(filename)
    opens a DDF file, decodes the header, and returns an opaque handle for use with subsequent calls. It fails if any problems are encountered. Instead of a filename, an already-open file can be supplied.
--------------------------------------------------------------------------------
Section:
ddfdda(handle)
    returns a list of records containing data from the Data Descriptive Area (DDA) of the file header. Each record contains the following fields:

        tag             DDR entry tag
        control         field control data
        name            field name
        abels           list of field labels
        format          data format

    The records may also contain other fields used internally.
--------------------------------------------------------------------------------
Section:
ddfread(handle)
    reads the next data record from the file. It returns a list of lists, with each sublist containing a tag name followed by the associated data values, already decoded according to the specification given in the header.
--------------------------------------------------------------------------------
Section:
ddfclose(handle)
    closes a DDF file.
################################################################################
File:
dif.icn
********************************************************************************
Description:
Procedure to check for differences
********************************************************************************
Additional Notes:
    dif(stream, compare, eof, group)
        generates a sequence of differences between an arbitrary number of input streams. Each result is returned as a list of diff_recs, one for each input stream, with each diff_rec containing a list of items that differ and their position in the input stream.

The diff_rec type is declared as:

        record diff_rec(pos,diffs)

    dif() fails if there are no differences, i.e. it produces an empty result sequence.
********************************************************************************
Detail Description:
--------------------------------------------------------------------------------
Section:
For example, if two input streams are:

    a b c d e f g h
    a b d e f i j

the output sequence would be:

    [diff_rec(3,[c]),diff_rec(3,[])]
    [diff_rec(7,[g,h]),diff_rec(6,[i,j])
--------------------------------------------------------------------------------
Section:
The arguments to dif(stream,compare,eof,group) are:

    stream          A list of data objects that represent input streams from which dif will extract its input "records". The elements can be of several different types which result in different actions, as follows:

                Type                Action
            ===========     =============================
            file            file is "read" to get records

            co-expression   co-expression is activated to get records

            list            records are "gotten" (get()) from the list

            diff_proc       a record type defined in "dif" to allow a procedure (or procedures) suppled by dif's caller to be called to get records. Diff_proc has two fields, the procedure to call and the argument to call it with. Its definition looks like this:

                            record diff_proc(proc,arg)
--------------------------------------------------------------------------------
Section:
Optional arguments:
    compare     Item comparison procedure -- succeeds if "equal", otherwise fails (default is the identity "===" comparison). The comparison must allow for the fact that the eof object (see next) might be an argument, and a pair of eofs must compare equal.

    eof         An object that is distinguishable from other objects in the stream.  Default is &null.

    group       A procedure that is called with the current number of unmatched items as its argument. It must return the number of matching items required for file synchronization to occur. Default is the formula Trunc((2.0 * Log(M)) + 2.0) where M is the number of unmatched items.
################################################################################
File:
digitcnt.icn
********************************************************************************
Description:
Procedure to count number of digits in file
********************************************************************************
Additional Notes:
This procedure counts the number of each digit in a file and returns a ten-element list with the counts.
################################################################################
File:
divide.icn
********************************************************************************
Description:
Procedure to perform long division
********************************************************************************
Additional Notes:
Doesn't get the decimal point.  Not sure what the padding does; to study.
################################################################################
File:
ebcdic.icn
********************************************************************************
Description:
Procedures to convert between ASCII and EBCDIC
********************************************************************************
Additional Notes:
These procedures assist in use of the ASCII and EBCDIC character sets, regardless of the native character set of the host:

    Ascii128()          Returns a 128-byte string of ASCII characters in numerical order.  Ascii128() should be used in preference to &ascii for applications which might run on an EBCDIC host.

    Ascii256()          Returns a 256-byte string representing the 256-character ASCII character set.  On an EBCDIC host, the order of the second 128 characters is essentially arbitrary.

    Ebcdic()            Returns a 256-byte string of EBCDIC characters in numerical order.

    AsciiChar(i)        Returns the character whose ASCII representation is i.

    AsciiOrd(c)         Returns the position of the character c in the ASCII collating sequence.

    EbcdicChar(i)       Returns the character whose EBCDIC representation is i.

    EbcdicOrd(c)        Returns the position of the character c in the EBCDIC collating sequence.

    MapEtoA(s)          Maps a string of EBCDIC characters to the equivalent ASCII string, according to a plausible mapping.

    MapAtoE(s)          Maps a string of ASCII characters to the equivalent EBCDIC string, according to a plausible mapping.

    Control(c)          Returns the "control character" associated with the character c.  On an EBCDIC host, with $ representing an EBCDIC character with no 7-bit ASCII equivalent, Control("$") may not be identical to "\^$", as translated by ICONT (and neither result is particularly meaningful).
********************************************************************************
Detail Description:
--------------------------------------------------------------------------------
Section:
Notes:
    There is no universally accepted mapping between ASCII and EBCDIC. See the SHARE Inc. publication "ASCII and EBCDIC Character Set and Code Issues in Systems Application Architecture" for more information than you would ever want to have on this subject.

    The mapping of the first 128 characters defined below by Ascii128() is the most commonly accepted mapping, even though it probably is not exactly like the mapping used by your favorite PC to mainframe file transfer utility. The mapping of the second 128 characters is quite arbitrary, except that where an alternate translation of ASCII char(n) is popular, this translation is assigned to Ascii256()[n+129].

    The behavior of all functions in this package is controlled solely by the string literals in the _Eascii() procedure. Therefore you may modify these strings to taste, and still obtain consistent results, provided that each character appears exactly once in the result of _Eascii().

    Yes, it's really true that the EBCDIC "\n" (NL, char(16r15)) is not the same as "\l" (LF, char(16r25)). How can that be?  "Don't blame me, man, I didn't do it."
################################################################################
File:
empgsup.icn
********************************************************************************
Description:
Procedure to support empg
********************************************************************************
Additional Notes:
This procedure is called by timing programs produced by empg. It a "delta" timing value used to adjust timings.
################################################################################
File:
emptygen.icn
********************************************************************************
Description:
Procedures for meta-translation code generation
********************************************************************************
Additional Notes:
This program is designed to be linked with the output of the meta-translator. As given here, they produce an identity translation. Modifications can be made to effect different translations.

The procedures here are just wrappers. This file is a skeleton that can be used as a basis for code-generation procedures.
********************************************************************************
Detail Description:
--------------------------------------------------------------------------------
Section:
Bug:
The invocable declaration is not handled properly. "invocable all" will get by, but some other forms produce syntax errors. The problem is in the meta-translator itself, not in this program.
--------------------------------------------------------------------------------
Section:
    Mp()                        -   call meta-procedure, any of the procedures below. Called from main procedure.
    Alt(e1, e2)                 -   e1 | e2
    Apply(e1, e2)               -   e1 ! e2
    Arg(e)                      -   procedure argument (parameter)
    Asgnop(op, e1, e2)          -   e1 op e2
    Augscan(e1, e2)             -   e1 ?:= e2
    Bamper(e1, e2)              -   e1 & e2
    Binop(op, e1, e2)           -   e1 op e2
    Body(es[])                  -   procedure body
    Break(e)                    -   break e
    Case(e, clist)              -   case e of { caselist }
    Cclause(e1, e2)             -   e1 : e2
    Clist(cclause1, cclause2)   -   cclause1 ; cclause2
    Clit(c)                     -   'c'
    Compound(es[])              -   { e1; e2; ... }
    Create(e)                   -   create e
    Default(e)                  -   default: e
    End()                       -   end
    Every(e)                    -   every e
    EveryDo(e1, e2)             -   every e1 do e2
    Fail()                      -   fail
    Field(e, f)                 -   e . f
    Global(vs[])                -   global v1, v2, ...
    If(e1, e2)                  -   if e1 then e2
    IfElse(e1, e2, e3)          -   if e1 then e2 else e3
    Ilit(i)                     -   i
    Initial(e)                  -   initial e
    Invocable(ss[])             -   invocable s1, s2, ... (problem)
    Invoke(e, es[])             -   e(e1, e2, ...)
    Key(s)                      -   &s
    Limit(e1, e2)               -   e1 \ e2
    Link(vs[])                  -   link "v1, v2, ..."
    List(es[])                  -   [e1, e2, ... ]
    Local(vs[])                 -   local v1, v2, ...
    Next()                      -   next
    Not(e)                      -   not e
    Null()                      -   &null
    Paren(es[])                 -   (e1, e2, ... )
    Pdco(e, es[])               -   e{e1, e2, ... }
    Proc(n, vs[])               -   procedure n(v1, v2, ...)
    Record(n, fs[])             -   record n(f1, f2, ...)
    Repeat(e)                   -   repeat e
    Return(e)                   -   return e
    Rlit(r)                     -   r
    Scan(e1, e2)                -   e1 ? e2
    Section(op, e1, e2, e3)     -   e1[e2 op  e3]
    Slit(s)                     -   "s"
    Static(vs[])                -   static v1, v2, ..
    Subscript(e1, e2)           -   e1[e2]
    Suspend(e)                  -   suspend e
    SuspendDo(e1, e2)           -   suspend e1 do e2
    To(e1, e2)                  -   e1 to e2
    ToBy(e1, e2, e3)            -   e1 to e2 by e3
    Repalt(e)                   -   |e
    Unop(op, e)                 -   op e
    Until(e)                    -   until e
    UntilDo(e1, e2)             -   until e1 do e2
    Var(v)                      -   v
    While(e)                    -   while e
    WhileDo(e1, e2)             -   while e1 do e2
################################################################################
File:
equiv.icn
********************************************************************************
Description:
Procedure to compare structures
********************************************************************************
Additional Notes:
        equiv(s,y)      compare arbitrary structures x and y

The procedure equiv() tests for the "equivalence" of two values. For types other than structures, it does the same thing as x1 === x2. For structures, the test is for "shape".  For example,

    equiv([],[])

succeeds.

It handles loops, but does not recognize them as such. For example, given

    L1 := []
    L2 := []
    put(L1,L1)
    put(L2,L1)

    equiv(L1,L2)

succeeds.

The concept of equivalence for tables and sets is not quite right if their elements are themselves structures. The problem is that there is no concept of order for tables and sets, yet it is impractical to test for equivalence of their elements without imposing an order. Since structures sort by "age", there may be a mismatch between equivalentstructures in two tables or sets.

Note:
The procedures equiv and ldag have a trailing argument that is used on internal recursive calls; a second argument must not be supplied by the user.
################################################################################
File:
escape.icn
********************************************************************************
Description:
Procedures to interpret Icon literal escapes
********************************************************************************
Additional Notes:
The procedure escape(s) produces a string in which Icon quotedliteral escape conventions in s are replaced by the corresponding characters. For example, escape("\\143\\141\\164") produces the string "cat".
################################################################################
File:
escapesq.icn
********************************************************************************
Description:
Procedures to deal with character string escapes
********************************************************************************
Additional Notes:
Procedure kit for dealing with escape sequences in Icon character string representations. Note that Icon escape sequences are very similar to C escapes, so this works for C strings, too.

    escapeseq()     --  a matching procedure for Icon string escape sequences

    escchar()       --  produces the character value of an Icon string escape sequence

    escape()        --  converts a string with escape sequences (as in Icon string representation) to the string it represents with escape

    quotedstring()  --  matching routine for a quoted string.
################################################################################
File:
eval.icn
********************************************************************************
Description:
Procedure to evaluate string as a call
********************************************************************************
Additional Notes:
This procedure analyzes a string representing an Icon function or procedure call and evaluates the result. Operators can be used in functional form, as in "*(2,3)".

This procedure cannot handle nested expressions or control structures.

It assumes the string is well-formed. The arguments can only be Icon literals. Escapes, commas, and parentheses in strings literals are not handled.

In the case of operators that are both unary and binary, the binary form is used.
################################################################################
File:
evallist.icn
********************************************************************************
Description:
Procedure to produce a list generated by expression
********************************************************************************
Additional Notes:
This procedure takes an expression, produces a program encapsulating it, and puts the results written by the program in a list.

It is called as evallist(expr, n, ucode, ...) where expr is an expression (normally a generator), n is the maximum size of the list, and the trailing arguments are ucode files to link with the expression.
################################################################################
File:
eventgen.icn
********************************************************************************
Description:
Procedures for meta-variant code generation
********************************************************************************
Additional Notes:
This program is designed to be linked with the output of the meta-variant translator.

It is designed to insert event-reporting code in Icon programs.
********************************************************************************
Detail Description:
--------------------------------------------------------------------------------
Section:
Bug:
The invocable declaration is not handled properly. "invocable all" will get by, but some other forms produce syntax errors. The problem is in the meta-variant translator itself, not in this program.
--------------------------------------------------------------------------------
Section:
    Alt(e1, e2)                 -   e1 | e2
    Apply(e1, e2)               -   e1 ! e2
    Arg(e)                      -   procedure argument (parameter)
    Asgnop(op, e1, e2)          -   e1 op e2
    Augscan(e1, e2)             -   e1 ?:= e2
    Bamper(e1, e2)              -   e1 & e2
    Binop(op, e1, e2)           -   e1 op e2
    Body(es[])                  -   procedure body
    Break(e)                    -   break e
    Case(e, clist)              -   case e of { caselist }
    Cclause(e1, e2)             -   e1 : e2
    Clist(cclause1, cclause2)   -   cclause1 ; cclause2
    Clit(c)                     -   'c'
    Compound(es[])              -   { e1; e2; ... }
    Create(e)                   -   create e
    Default(e)                  -   default: e
    End()                       -   end
    Every(e)                    -   every e
    EveryDo(e1, e2)             -   every e1 do e2
    Fail()                      -   fail
    Field(e, f)                 -   e . f
    Global(vs[])                -   global v1, v2, ...
    If(e1, e2)                  -   if e1 then e2
    IfElse(e1, e2, e3)          -   if e1 then e2 else e3
    Ilit(i)                     -   i
    Initial(e)                  -   initial e
    Invocable(ss[])             -   invocable s1, s2, ... (problem)
    Invoke(e, es[])             -   e(e1, e2, ...)
    Key(s)                      -   &s
    Limit(e1, e2)               -   e1 \ e2
    Link(vs[])                  -   link "v1, v2, ..."
    List(es[])                  -   [e1, e2, ... ]
    Local(vs[])                 -   local v1, v2, ...
    Next()                      -   next
    Not(e)                      -   not e
    Null()                      -   &null
    Paren(es[])                 -   (e1, e2, ... )
    Pdco(e, es[])               -   e{e1, e2, ... }
    Proc(n, vs[])               -   procedure n(v1, v2, ...)
    Record(n, fs[])             -   record n(f1, f2, ...)
    Repeat(e)                   -   repeat e
    Return(e)                   -   return e
    Rlit(r)                     -   r
    Scan(e1, e2)                -   e1 ? e2
    Section(op, e1, e2, e3)     -   e1[e2 op  e3]
    Slit(s)                     -   "s"
    Static(vs[])                -   static v1, v2, ..
    Subscript(e1, e2)           -   e1[e2]
    Suspend(e)                  -   suspend e
    SuspendDo(e1, e2)           -   suspend e1 do e2
    To(e1, e2)                  -   e1 to e2
    ToBy(e1, e2, e3)            -   e1 to e2 by e3
    Repalt(e)                   -   |e
    Unop(op, e)                 -   op e
    Until(e)                    -   until e
    UntilDo(e1, e2)             -   until e1 do e2
    Var(v)                      -   v
    While(e)                    -   while e
    WhileDo(e1, e2)             -   while e1 do e2
################################################################################
File:
everycat.icn
********************************************************************************
Description:
Procedure for generating all concatenations
********************************************************************************
Additional Notes:
    everycat(x1, x2, ...) generates the concatenation of every string from !x1, !x2, ... .

For example, if

    first := ["Mary", "Joe", "Sandra"]
    last := ["Smith", "Roberts"]

then

    every write(everycat(first, " ", last))

writes

    Mary Smith
    Mary Roberts
    Joe Smith
    Joe Roberts
    Sandra Smith
    Sandra Roberts

Note that x1, x2, ... can be any values for which !x1, !x2, ... produce strings or values convertible to strings. In particular, in the example above, the second argument is a one-character string " ", so that !" " generates a single blank.
################################################################################
File:
expander.icn
********************************************************************************
Description:
Procedures to convert character pattern expressions
********************************************************************************
Additional Notes:
pfl2str(pattern) expands pattern-form expressions, which have the form

    [<expr><op><expr>]

to the corresponding string.

The value of <op> determines the operation to be performed.

    pfl2gxp(pattern) expands pattern-form expressions into generators that, when compiled and evaluated, produce the corresponding string.

    pfl2pwl(pattern) converts pattern-form expressions to Painter's weaving language.
################################################################################
File:
exprfile.icn
********************************************************************************
Description:
Procedures to produce programs on the fly
********************************************************************************
Additional Notes:
    exprfile(exp, link, ...)
            produces a pipe to a program that writes all the results generated by exp. The trailing arguments name link files needed for the expression.

            exprfile() closes any previous pipe it opened and deletes its temporary file. Therefore, exprfile() cannot be used for multiple expression pipes.

            If the expression fails to compile, the global expr_error is set to 1; otherwise 0.

    exec_expr(expr_list, links[])
            generates the results of executing the expression contained in the lists expr_list with the specified links.

    plst2pstr(L)
            converts the list of Icon programs lines in L to a string with separating newlines.

    pstr2plst(s)
            converts the string of Icon program lines (separated by newlines) to a list of lines.

    ucode(file)
            produces a ucode file from the Icon program in file.
################################################################################
File:
factors.icn
********************************************************************************
Description:
Procedures related to factors and prime numbers
********************************************************************************
Additional Notes:
This file contains procedures related to factorization and prime numbers.

    divisors(n)         generates the divisors of n.

    factorial(n)        returns n!.  It fails if n is less than 0.

    factors(i, j)       returns a list containing the prime factors of i limited to maximum value j; default, no limit.

    genfactors(i, j)    like factors(), except factors are generated as they are found.

    gfactorial(n, i)    generalized factorial; n x (n - i) x (n - 2i) x ...

    ispower(i, j)       succeeds and returns root if i is k^j

    isprime(n)          succeeds if n is a prime.

    nxtprime(n)         returns the next prime number beyond n.

    pfactors(i)         returns a list containing the primes that divide i.

    prdecomp(i)         returns a list of exponents for the prime decomposition of i.

    prime()             generates the primes.

    primel()            generates the primes from a precompiled list.

    primorial(i,j)      product of primes j <= i; j defaults to 1.

    sfactors(i, j)      as factors(i, j), except output is in string form with exponents for repeated factors

    squarefree(i)       succeeds if i is square free

Notes:  Some of these procedures are not fast enough for extensive work. Factoring is believed to be a hard problem. factors() should only be used for small numbers.

Requires: Large-integer arithmetic; prime.lst for primel() and primorial().
################################################################################
File:
fastfncs.icn
********************************************************************************
Description:
Procedures for integer functions using fastest method
********************************************************************************
Additional Notes:
These procedures implement integer-valued functions using the fastest method known to the author. "Fastest" does not mean "fast".

    acker(i, j)         Ackermann's function
    fib(i)              Fibonacci sequence
    g(k, i)             Generalized Hofstader nested recurrence
    q(i)                "Chaotic" sequence
    robbins(i)          Robbins numbers
################################################################################
File:
feval.icn
********************************************************************************
Description:
Procedure to evaluate string as function call
********************************************************************************
Additional Notes:
This procedure analyzes a string representing an Icon function or procedure call and evaluates the result.

It assumes the string is well-formed.  The arguments can only be Icon literals. Escapes, commas, and parentheses in strings literals are not handled.
################################################################################
File:
filedim.icn
********************************************************************************
Description:
Procedure to compute file dimensions
********************************************************************************
Additional Notes:
filedim(s, p) computes the number of rows and maximum column width of the file named s. The procedure p, which defaults to detab, i applied to each line. For example, to have lines left as is, use

    filedim(s, 1)
################################################################################
File:
filenseq.icn
********************************************************************************
Description:
Procedure to get highest numbered filename in a sequence
********************************************************************************
Additional Notes:
This procedure is useful when you need to create the next file in a series of files (such as successive log files).

Usage:

    fn := nextseqfilename( ".", "$", "log")

returns the (non-existent) filename next in the sequence .\$*.log (where the * represents 1, 2, 3, ...) or fails

################################################################################
File:
filesize.icn
********************************************************************************
Description:
Procedure to get the size of a file
********************************************************************************
Additional Notes:
    filesize(s)         returns the number of characters in the file named s; it fails if s cannot be opened.
################################################################################
File:
findre.icn
********************************************************************************
Description:
Procedure to find regular expression
********************************************************************************
Additional Notes:
    findre() is like the Icon builtin function find(), except that it takes, as its first argument, a regular expression pretty much like the ones the Unix egrep command uses (the few minor differences are listed below). Its syntax is the same as find's (i.e. findre(s1,s2,i,j)), with the exception that a no-argument invocation wipes out all static structures utilized by findre, and then forces a garbage collection.

(For those not familiar with regular expressions and the Unix egrep command: findre() offers a simple and compact wildcard-based search system. If you do a lot of searches through text files, or write programs which do searches based on user input, then findre is a utility you might want to look over.)

********************************************************************************
Detail Description:
--------------------------------------------------------------------------------
Section:
IMPORTANT DIFFERENCES between find and findre:
As noted above, findre() is just a find() function that takes a regular expression as its first argument.  One major problem with this setup is that it leaves the user with no easy way to tab past a matched substring, as with

    s ? write(tab(find("hello")+5))

In order to remedy this intrinsic deficiency, findre() sets the global variable __endpoint to the first position after any given match occurs. Use this variable with great care, preferably assigning its value to some other variable immediately after the match (for example, findre("hello [.?!]*",s) & tmp := __endpoint). Otherwise, you will certainly run into trouble.  (See the example below for an illustration of how __endpoint is used).
--------------------------------------------------------------------------------
Section:
IMPORTANT DIFFERENCES between egrep and findre:
findre utilizes the same basic language as egrep. The only big difference is thatfindre uses intrinsic Icon data structures and escaping conventions rather than those of any particular Unix variant. Be careful!  If you put findre("\(hello\)",s) into your source file, findre will treat it just like findre("(hello)",s). If, however, you enter '\(hello\)' at run-time (via, say, findre(!&input,s)), what Icon receives will depend on your operating system (most likely, a trace will show "\\(hello\\)").

It is designed to insert event-reporting code in Icon programs.
--------------------------------------------------------------------------------
Section:
BUGS:
Space has essentially been conserved at the expense of time in the automata produced by findre(). The algorithm, in other words, will produce the equivalent of a pushdown automaton under certain circumstances, rather than strive (at the expense of space) for full determinism. I tried to make up a nfa -> dfa converter that would only create that portion of the dfa it needed to accept or reject a string, but the resulting automaton was actually quite slow (if anyone can think of a way to do this in Icon, and keep it small and fast, please let us all know about it). Note that under version 8 of Icon, findre takes up negligible storage space, due to the much improved hashing algorithm.  I have not tested it under version 7, but I would expect it to use up quite a bit more space in that environment.
--------------------------------------------------------------------------------
Section:
IMPORTANT NOTE:
Findre takes a shortest-possible-match approach to regular expressions. In other words, if you look for "a*", findre will not even bother looking for an "a." It will just match the empty string.  Without this feature, findre would perform a bit more slowly. The problem with such an approach is that often the user will want to tab past the longest possible string of matched characters (say tab((findre("a*|b*"), __endpoint)). In circumstances like this, please just use something like:

        s ? {
            tab(find("a")) &  # or use Arb() from the IPL (patterns.icn)
            tab(many('a'))
            tab(many('b'))
        }

or else use some combination of findre and the above.
--------------------------------------------------------------------------------
Section:
REGULAR EXPRESSION SYNTAX:
Regular expression syntax is complex, and yet simple. It is simple in the sense that most of its power is concentrated in about a dozen easy-to-learn symbols. It is complex in the sense that, by combining these symbols with characters, you can represent very intricate patterns.

I make no pretense here of offering a full explanation of regular expressions, their usage, and the deeper nuances of their syntax. As noted above, this should be gleaned from a Unix manual. For quick reference, however, I have included a brief summary of all the special symbols used, accompanied by an explanation of what they mean, and, in some cases, of how they are used (most of this is taken from the comments prepended to Jerry Nowlin's Icon-grep command, as posted a couple of years ago):

        ^   -   matches if the following pattern is at the beginning of a line (i.e. ^# matches lines beginning with "#")
        $   -   matches if the preceding pattern is at the end of a line
        .   -   matches any single character
        +   -   matches from 1 to any number of occurrences of the previous expression (i.e. a character, or set of parenthesized/bracketed characters)
        *   -   matches from 0 to any number of occurrences of the previous expression
        \   -   removes the special meaning of any special characters recognized by this program (i.e if you want to match lines beginning with a "[", write ^\[, and not ^[)
        |   -   matches either the pattern before it, or the one after it (i.e. abc|cde matches either abc or cde)
        []  -   matches any member of the enclosed character set, or, if ^ is the first character, any nonmember of the enclosed character set (i.e. [^ab] matches any character except a and b).
        ()  -   used for grouping (e.g. ^(abc|cde)$ matches lines consisting of either "abc" or "cde," while ^abc|cde$ matches lines either beginning with "abc" or ending in "cde")
--------------------------------------------------------------------------------
Section:
EXAMPLE program:

    procedure main(a)
        while line := !&input do {
            token_list := tokenize_line(line,a[1])
            every write(!token_list)
        }
    end

    procedure tokenize_line(s,sep)
        tmp_lst := []
        s ? {
            while field := tab(findre(sep)|0) & mark := __endpoint do {
                put(tmp_lst,"" ~== field)
                if pos(0) then break
                else tab(mark)
            }
        }
        return tmp_lst
    end

The above program would be compiled with findre (e.g. "icont test_prg.icn findre.icn") to produce a single executable which tokenizes each line of input based on a user-specified delimiter. Note how __endpoint is set soon after findre() succeeds. Note also how empty fields are excluded with "" ~==, etc. Finally, note that the temporary list, tmp_lst, is not needed.  It is included here merely to illustrate one way in which tokens might be stored.

Tokenizing is, of course, only one of many uses one might put findre to. It is very helpful in allowing the user to construct automata at run-time. If, say, you want to write a program that searches text files for patterns given by the user, findre would be a perfect utility to use. Findre in general permits more compact expression of patterns than one can obtain using intrinsic Icon scanning facilities. Its near complete compatibility with the Unix regexp library, moreover, makes for greater ease of porting, especially in cases where Icon is being used to prototype C code.
################################################################################
File:
ftype.icn
********************************************************************************
Description:
Procedure to produce type for file
********************************************************************************
Additional Notes:
This procedure returns the file identification produced by file(1).
################################################################################
File:
fullimag.icn
********************************************************************************
Description:
Procedures to produce complete image of structured data
********************************************************************************
Additional Notes:
    fullimage() -- enhanced image()-type procedure that outputs all data contained in structured types. The "level" argument tells it how far to descend into nested structures (defaults to unlimited).
################################################################################
File:
gauss.icn
********************************************************************************
Description:
Procedures to compute Gaussian distributions
********************************************************************************
Additional Notes:
    gauss_random(x, f) produces a Gaussian distribution about the value x. The value of f can be used to alter the shape of the Gaussian distribution (larger values flatten the curve...)
################################################################################
File:
gdl.icn
********************************************************************************
Description:
Procedures to get directory lists
********************************************************************************
Additional Notes:
Gdl returns a list containing everything in a directory (whose name must be passed as an argument to gdl). Nothing fancy. I use this file as a template, modifying the procedures according to the needs of the program in which they are used.
################################################################################
File:
gdl2.icn
********************************************************************************
Description:
Procedures to get directory lists
********************************************************************************
Additional Notes:
Gdl returns a list containing everything in a directory (whose name must be passed as an argument to gdl). Nothing fancy. I use this file as a template, modifying the procedures according to the needs of the program in which they are used.

NOTE: MSDOS results are all in lower case

Modifications:
    1) Fixed MSDOS routines.
    2) Added gdlrec which does same thing as gdl except it recursively descendsthrough subdirectories. May choose which Unix utility to use by passing in method parameter.
################################################################################
File:
gedcom.icn
********************************************************************************
Description:
Procedures for reading GEDCOM files
********************************************************************************
Additional Notes:
These procedures read and interpret GEDCOM files, a standard format for genealogy databases.
********************************************************************************
Detail Description:
--------------------------------------------------------------------------------
Section:
    gedload(f)      loads GEDCOM data from file f and returns a gedcom record containing the following fields:
        tree        root of tree of gednode records
        id          table of labeled nodes, indexed by @ID@
        fam         list of FAM nodes (marriages)
        ind         list of INDI nodes (individuals)

The tree is composed of gednode records R containing these fields:
        level       level
        id          ID (label), including @...@ delimiters
        tag         tag
        data        data
        lnum        line number
        parent      parent node in tree
        ref         referenced node, if any
        sub         sub-entry list
        hcode       unique hashcode, if INDI node
--------------------------------------------------------------------------------
Section:
    gedwalk(tree) generates the nodes of the tree in preorder.

Three procedures find descendants of a node based on a sequence of identifying tag strings:
        gedsub(R, tag...) generates subnodes specified by tag sequence
        gedval(R, tag...) generates data values of those subnodes
        gedref(R, tag...) generates nodes referenced by those subnodes

Three procedures extract a person's name from an INDI record:
        gedfnf(R)   produces "John Quincy Adams" form
        gedlnf(R)   produces "Adams, John Quincy" form
        gednmf(R,f) produces an arbitrary format, substituting prefix, firstname, lastname, suffix for "P", "F", "L", "S" (respectively) in f
--------------------------------------------------------------------------------
Section:
    geddate(R) finds the DATE subnode of a node and returns a string of at least 12 characters in a standard form such as "11 Jul 1767" or "abt 1810".  It is assumed that the input is in English.

    gedyear(r) get year from event record
--------------------------------------------------------------------------------
Section:
    gedfind(g,s) generates the individuals under gedcom record g that are named by s, a string of whitespace-separated words.

    gedfind()  generates each INDI node for which every word of s is matched by either a word of the individual's name or by the birth year.  Matching is case-insensitive.
--------------------------------------------------------------------------------
Section:
    gedscan(f) scan one line of a GEDCOM record, returning gednode record
--------------------------------------------------------------------------------
Section:
    gedhi(r)   generate hashcode for individual record. The hashcode uses two initials, final digits of birth year, and a 3-letter hashing of the full name and birthdate fields.

    gedh3a(s)  hash arbitrary string into three alphabetic characters
--------------------------------------------------------------------------------
Section:
    gedmatch(r, s)  match record against name. s is a string of words to match name field and/or birth year. Matching is case sensitive.
--------------------------------------------------------------------------------
Section:
    gedlcw(s, c) -- generate words from string s separated by chars from c. words are mapped to lower-case to allow case-insensitive comparisons
################################################################################
################################################################################
################################################################################
################################################################################
################################################################################
################################################################################
################################################################################
################################################################################
################################################################################
################################################################################
################################################################################
################################################################################
################################################################################
################################################################################
################################################################################








