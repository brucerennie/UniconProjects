################################################################################
File:
abkform.icn
********************************************************************************
Description:
Procedures set to read and write HP95LX appointment book (.abk) files.
********************************************************************************
Additional Notes:
1. Files created by the Appointment Book application may contain some padding following the last field of some data records.  Hence, the RecordLength field must be used to determine the start of the next record.  Appointment book files created by other programs need not have any padding.

2. ApptState has several bit fields.  Only bit 0 is meaningful to software processing an appointment book file.  Bit 0 being set or cleared corresponds to the alarm being enabled or disabled, respectively. Programs creating Appointment book files should clear all bits, except perhaps bit 0.

3. ToDoState has two one-bit bit fields.  Bit 0 being set or cleared corresponds to carry forward being enabled or disabled for this todo item, respectively.  Bit 1 being set or cleared corresponds to the todo being checked off or not checked off, respectively.

4. Appointment and ToDo texts are each limited to a maximum of 27 characters.

5. Note text is limited to a maximum of 11 lines of 39 characters per line (not counting the line terminator).
********************************************************************************
Detail Description:
--------------------------------------------------------------------------------
Section:
HP 95LX Appointment Book File Format
The HP 95LX Appointment Book file is structured as a file-identification record, followed by a settings record, followed by a variable number of data records, and terminated by an end-of-file record. There are multiple types of data records corresponding to the different types of appointment book entries.

The formats of these appointment book records is described in the following tables. In the descriptions, the type <int> refers to a two-byte integer stored least significant byte first, the type <swpint> refers to a two-byte integer stored most significant byte first, the type <char> refers to a one-byte integer, and the type <ASCII> refers to a string of ASCII characters.
--------------------------------------------------------------------------------
Section:
HP 95LX Appointment Book File Identification Record:
Byte Offset      Name            Type     Contents

0                ProductCode     int      -1 (FFh, FFh)
2                ReleaseNum      int      1 (01h, 00h)
4                FileType        char     1 (01h)
--------------------------------------------------------------------------------
Section:
HP 95LX Appointment Book Settings Record:
Byte Offset      Name            Type     Contents

0                StartTime       int      Daily display start time as the number of minutes past midnight.
2                Granularity     int      Daily display time line granularity in minutes.
4                AlarmEnable     char     1 = on, 0 = off
5                LeadTime        char     Alarm default lead time in minutes.
6                CarryForward    char     To do carry forward default, 1 = on, 0 = off.
--------------------------------------------------------------------------------
Section:
HP 95LX Appointment Book Daily Data Record:
Byte Offset      Name            Type     Contents

0                RecordType      char     1 (01h)
1                RecordLength    int      Number of bytes in remainder of this data record, see note 1 below.
3                ApptState       char     See note 2 below.
4                Year            char     Year counting from 1900.
5                Month           char     Month, 1 - 12.
6                Day             char     Day, 1 - 31.
7                StartTime       swpint   Start time in minutes since midnight.
9                EndTime         int      End time in minutes since midnight.
11               LeadTime        char     Alarm lead time in minutes, 0 - 30.
12               ApptLength      char     Length of appointment text in bytes.
13               NoteLength      int      Length of note text in bytes.
15               ApptText        ASCII    Appointment text - see note 4 below.
15+ApptLength    NoteText        ASCII    Note text where the null character is used as the line terminator - see note 5.
--------------------------------------------------------------------------------
Section:
HP 95LX Appointment Book Weekly Data Record:
Byte Offset      Name            Type     Contents

0                RecordType      char     2 (02h)
1                RecordLength    int      Number of bytes in remainder of this data record, see note 1 below.
3                ApptState       char     See note 2 below.
4                DayOfWeek       char     Day of week, 1=Sun, ..., 7=Sat.
5                StartTime       swpint   Start time in minutes since midnight.
7                StartYear       char     Start year counting from 1900.
8                StartMonth      char     Start month, 1 - 12.
9                StartDay        char     Start day, 1 - 31.
10               EndTime         int      End time in minutes since midnight.
12               EndYear         char     End year counting from 1900.
13               EndMonth        char     End month, 1 - 12.
14               EndDay          char     End day, 1 - 31.
15               LeadTime        char     Alarm lead time in minutes, 0 - 30.
16               ApptLength      char     Length of appointment text in bytes.
17               NoteLength      int      Length of note text in bytes.
19               ApptText        ASCII    Appointment text - see note 4 below.
19+ApptLength    NoteText        ASCII    Note text where the null character is used as the line terminator - see note 5 below.
--------------------------------------------------------------------------------
Section:
HP 95LX Appointment Book Monthly by Date Data Record:
Byte Offset      Name            Type     Contents

0                RecordType      char     3 (03h)
1                RecordLength    int      Number of bytes in remainder of this data record, see note 1 below.
3                ApptState       char     See note 2 below.
4                DayOfMonth      char     Day of month, 1 - 31.
5                StartTime       swpint   Start time in minutes since midnight.
7                StartYear       char     Start year counting from 1900.
8                StartMonth      char     Start month, 1 - 12.
9                StartDay        char     Start day, 1 - 31.
10               EndTime         int      End time in minutes since midnight.
12               EndYear         char     End year counting from 1900.
13               EndMonth        char     End month, 1 - 12.
14               EndDay          char     End day, 1 - 31.
15               LeadTime        char     Alarm lead time in minutes, 0 - 30.
16               ApptLength      char     Length of appointment text in bytes.
17               NoteLength      int      Length of note text in bytes.
19               ApptText        ASCII    Appointment text - see note 4 below.
19+ApptLength    NoteText        ASCII    Note text where the null character is used as the line terminator - see note 5 below.
--------------------------------------------------------------------------------
Section:
HP 95LX Appointment Book Monthly by Position Data Record:
Byte Offset      Name            Type     Contents

0                RecordType      char     4 (04h)
1                RecordLength    int      Number of bytes in remainder of this data record, see note 1 below.
3                ApptState       char     See note 2 below.
4                WeekOfMonth     char     Week of month, 1 - 5.
5                DayOfWeek       char     Day of week, 1=Sun, ..., 7=Sat.
6                StartTime       swpint   Start time in minutes since midnight.
8                StartYear       char     Start year counting from 1900.
9                StartMonth      char     Start month, 1 - 12.
10               StartDay        char     Start day, 1 - 31.
11               EndTime         int      End time in minutes since midnight.
13               EndYear         char     End year counting from 1900.
14               EndMonth        char     End month, 1 - 12.
15               EndDay          char     End day, 1 - 31.
16               LeadTime        char     Alarm lead time in minutes, 0 - 30.
17               ApptLength      char     Length of appointment text in bytes.
18               NoteLength      int      Length of note text in bytes.
20               ApptText        ASCII    Appointment text - see note 4 below.
20+ApptLength    NoteText        ASCII    Note text where the null character is used as the line terminator - see note 5 below.
--------------------------------------------------------------------------------
Section:
HP 95LX Appointment Book Yearly Data Record:
Byte Offset      Name            Type     Contents

0                RecordType      char     5 (05h)
1                RecordLength    int      Number of bytes in remainder of this data record, see note 1 below.
3                ApptState       char     See note 2 below.
4                MonthOfYear     char     Month of year, 1=Jan, ... 12=Dec.
5                DayOfMonth      char     Day of month, 1 - 31.
6                StartTime       swpint   Start time in minutes since midnight.
8                StartYear       char     Start year counting from 1900.
9                StartMonth      char     Start month, 1 - 12.
10               StartDay        char     Start day, 1 - 31.
11               EndTime         int      End time in minutes since midnight.
13               EndYear         char     End year counting from 1900.
14               EndMonth        char     End month, 1 - 12.
15               EndDay          char     End day, 1 - 31.
16               LeadTime        char     Alarm lead time in minutes, 0 - 30.
17               ApptLength      char     Length of appointment text in bytes.
18               NoteLength      int      Length of note text in bytes.
20               ApptText        ASCII    Appointment text - see note 4 below.
20+ApptLength    NoteText        ASCII    Note text where the null character is used as the line terminator - see note 5 below.
--------------------------------------------------------------------------------
Section:
HP 95LX Appointment Book To Do Data Record:
Byte Offset      Name            Type     Contents

0                RecordType      char     6 (06h)
1                RecordLength    int      Number of bytes in remainder of this data record, see note 1 below.
3                ToDoState       char     See note 3 below.
4                Priority        char     Priority, 1 - 9.
5                StartYear       char     Start year counting from 1900.
6                StartMonth      char     Start month, 1 - 12.
7                StartDay        char     Start day, 1 - 31.
8                CheckOffYear    char     Check off year counting from 1900, 0 indicates not checked off.
9                CheckOffMonth   char     Check off month, 1 - 12, 0 indicates not checked off.
10               CheckOffDay     char     Check off day, 1 - 31, 0 indicates not checked off.
11               ToDoLength      char     Length of to do text in bytes.
12               NoteLength      int      Length of note text in bytes.
14               ToDoText        ASCII    To do text - see note 4 below.
14+ToDoLength    NoteText        ASCII    Note text where the null character is used as the line terminator - see note 5 below.
--------------------------------------------------------------------------------
Section:
HP 95LX Appointment Book End of File Record:
Byte Offset      Name            Type     Contents
0                RecordType      char     50 (32h)
1                RecordLength    int      0 (00h, 00h)
################################################################################
File:
adjuncts.icn
********************************************************************************
Description:
Procedures for gettext and idxtext
********************************************************************************
Additional Notes:
Pretty mundane stuff. Set_OS(), Basename(), Pathname(), Strip(), and a utility for creating index filenames.
################################################################################
File:
adlutils.icn
********************************************************************************
Description:
Procedures to process address lists
********************************************************************************
Additional Notes:
Procedures used by programs that process address lists:

         nextadd()              get next address
         writeadd(add)          write address
         get_country(add)       get country
         get_state(add)         get state (U.S. addresses only)
         get_city(add)          get city (U.S. addresses only)
         get_zipcode(add)       get ZIP code (U.S. addresses only)
         get_lastname(add)      get last name
         get_namepfx(add)       get name prefix
         get_title(add)         get name title
         format_country(s)      format country name
################################################################################
File:
allof.icn
********************************************************************************
Description:
Procedure for conjunction control operation
********************************************************************************
Additional Notes:
allof{expr1,expr2} -- Control operation that performs iterative conjunction.

Iterative conjunction permits a conjunction expression to be built at run time which supports full backtracking among the created terms of the expression.  The computed expression can be of arbitrary length, and is built via an iterative loop in which one term is appended to the expression (as if connected with a "&" operator) per iteration.

Expr1 works like the control expression of "every-do"; it controls iteration by being resumed to produce all of its possible results. The allof{} expression produces the outcome of conjunction of all of the resulting instances of expr2.

For example:

       global c
       ...
       pattern := "ab*"
       "abcdef" ? {
          allof { c := !pattern ,
             if c == "*" then move(0 to *&subject - &pos + 1) else =c
             } & pos(0)
          }

This example will perform a wild card match on "abcdef" against pattern "ab*", where "*" in a pattern matches 0 or more characters. Since pos(0) will fail the first time it is evaluated, the allof{} expression will be resumed just as a conjunction expression would, and backtracking will propagate through all of the instances of expr2; the expression will ultimately succeed (as its conjunctive equivalent would).

Note that, due to the scope of variables in co-expressions, variables shared between expr1 and expr2 must have global scope, hence c in the above example must be global.

The allof{} procedure models Icon's expression evaluation mechanism in that it explicitly performs backtracking. The author of this procedure knows of no way to invoke Icon's built-in goal directed evaluation to perform conjunction of a arbitrary number of computed expressions (suggestions welcome).
################################################################################
File:
allpat.icn
********************************************************************************
Description:
Procedure to produce all n-character patterns of characters
################################################################################
File:
ansi.icn
********************************************************************************
Description:
Procedures for ANSI-based terminal control
********************************************************************************
Additional Notes:
This package of procedures implements a subset of the ANSI terminal control sequences.  The names of the procedures are taken directly from the ANSI names.  If it is necessary to use these routines with non-ANSI devices, link in iolib.icn, and (optionally) iscreen.icn as well.  Use will be made of whatever routines are made available via either of these libraries.  Be careful of naming conflicts if you link in iscreen.icn. It contains procedures like "clear" and "boldface."

        CUB(i)         Moves the cursor left i columns
        CUD(i)         Moves the cursor down i rows
        CUF(i)         Moves the cursor right i columns
        CUP(i,j)       Moves the cursor to row i, column j
        CUU(i)         Moves the cursor up i rows
        ED(i)          Erases screen: i = 0, cursor to end; i = 1, beginning to cursor; i = 2, all (default 2)
        EL(i)          Erases data in cursor row: i = 0, cursor to end; i = 1, beginning to cursor; i = 2, all (default 0)
        SGR(i)         Sets video attributes: 0 = off; 1 = bold; 4 = underscore; 5 = blink; 7 = reverse (default 0)

Note that not all so-called ANSI terminals support every ANSI screen control sequence - not even the limited subset included in this file.

If you plan on using these routines with non-ANSI magic-cookie terminals (e.g. a Wyse-50) then it is strongly recommended that you link in iolib or itlib *and* iscreen (not just iolib or itlib by itself).  The routines WILL WORK with most magic cookie terminals; they just don't always get all the modes displayed (because they are basically too busy erasing the cookies).
********************************************************************************
Detail Description:
For DOS, or any system using ANSI-conformant output devices, there is no need to link any routines in.

For UNIX systems, you may choose to link in itlib or iolib, and (if desired) iscreen as well.  Some of these may be in the IPL.  You can get any that aren't from Richard Goerwitz (goer@sophist.uchicago.edu).
################################################################################
File:
apply.icn
********************************************************************************
Description:
Procedure to apply a list of functions to an argument
********************************************************************************
Additional Notes:
This procedure applies a list of functions to an argument.  An example is

        apply([integer, log], 10)

which is equivalent to integer(log(10)).
################################################################################
File:
argparse.icn
********************************************************************************
Description:
Procedure to parse pseudo-command-line
********************************************************************************
Additional Notes:
argparse(s) parses s as if it were a command line and puts the components in in a list, which is returned.

At present, it does not accept any escape conventions.
################################################################################
File:
array.icn
********************************************************************************
Description:
Procedures for n-dimensional arrays
********************************************************************************
Additional Notes:
create_array([lbs], [ubs], value) creates a n-dimensional array with the specified lower bounds, upper bounds, and with each array element having the specified initial value.

ref_array(A, i1, i2, ...) references the i1-th i2-th ... element of A.
################################################################################
File:
array.icn
********************************************************************************
Description:
Procedures for n-dimensional arrays
********************************************************************************
Additional Notes:
create_array([lbs], [ubs], value) creates a n-dimensional array with the specified lower bounds, upper bounds, and with each array element having the specified initial value.

ref_array(A, i1, i2, ...) references the i1-th i2-th ... element of A.
################################################################################
File:
asciinam.icn
********************************************************************************
Description:
Procedure for ASCII name of unprintable character
********************************************************************************
Additional Notes:
asciiname(s) returns the mnemonic name of the single unprintable ASCII character s.
################################################################################
File:
base64.icn
********************************************************************************
Description:
Procedures for base64 encodings for MIME (RFC 2045)
********************************************************************************
Additional Notes:
base64encode( s1 ) : s2

   returns the base64 encoding of a string s1

base64decode( s1 ) : s2

   returns the base64 decoding of a string s1 fails if s1 isn't base64 encoded

references:  MIME encoding Internet RFC 2045
################################################################################
File:
basename.icn
********************************************************************************
Description:
Procedure to produce base name of file
********************************************************************************
Additional Notes:
This procedure is based on the UNIX basename(1) utility. It strips off any path information and removes the specified suffix, if present.

It should work under UNIX, MS-DOS, and the Macintosh.
################################################################################
File:
binary.icn
********************************************************************************
Description:
Procedures to pack and unpack values
********************************************************************************
Additional Notes:
This is a collection of procedures that support conversion of Icon data elements to and from binary data formats.  The purpose is to facilitate dealing with binary data files.

The procedures can be used individually or via the "control" procedures pack() and unpack().

The individual conversion functions are prefixed by either "pack_" or "unpack_" and are identified in comments by their format character(s). The "pack_" procedures convert from Icon to binary and take a single argument:  the value to be converted.  The "unpack_" procedures convert from binary to Icon and usually take no parameters -- they are executed within a string-scanning context and scan the necessary amount from the &subject string.  Some of the "unpack_" functions take a parameter that specifies the length of the output string.  The individual conversion procedures are minimally commented, but their action is apparent from their procedure names and the documentation of the pack() and unpack() procedures.

The control procedures pack() and unpack() take a format string that controls conversions of several values (similar to the "printf" C library function).  pack() and unpack() are patterned after the Perl (programming language) functions of the same names, and are documented below.

pack(template,value1,...) : packed_binary_string
------------------------------------------------

This procedure packs the "values" into a binary structure, returning the string containing the structure.  The elements of any lists in the "value" parameters are processed individually as if they were "spliced" into the "value" parameter list.  The "template" is a sequence of characters that give the order and type of values, as follows" (using C language terminology):

  a     An ascii string, will be null padded (unstripped for unpack()).
  A     An ascii string, will be space padded (trailing nulls and spaces will be stripped for unpack()).
  b     A bit string, low-to-high order.
  B     A bit string, high-to-low order.
  h     A hexadecimal string, low-nybble-first.
  H     A hexadecimal string, high-nybble-first.
  c     A signed char value.
  C     An unsigned char value.
  s     A signed short value.
  S     An unsigned short value.
  i     A signed int value.
  I     An unsigned int value.
  l     A signed long value.
  L     An unsigned long value.
  n     A short in "network" order (big-endian).
  N     A long in "network" order (big-endian).
  v     A short in "vax" order (little-endian).
  V     A long in "vax" order (little-endian).
  f     A single-precision float in IEEE Motorola format.
  d     A double-precision float in IEEE Motorola format.
  e     An extended-precision float in IEEE Motorola format 80-bit.
  E     An extended-precision float in IEEE Motorola format 96-bit.
  x     Skip forward a byte (null-fill for pack()).
  X     Back up a byte.
  @     Go to absolute position (null-fill if necessary for pack()).
  u     A uu-encoded/decoded string.

Each letter may optionally be followed by a number which gives a count.  Together the letter and the count make a field specifier. Letters and numbers can be separated by white space which will be ignored.  Types A, a, B, b, H, and h consume one value from the "value" list and produce a string of the length given as the field-specifier-count.  The other types consume "field-specifier-count" values from the "value" list and append the appropriate data to the packed string.

unpack(template,string) : value_list
------------------------------------

This procedure does the reverse of pack():  it takes a string representing a structure and expands it out into a list of values. The template has mostly the same format as for pack() -- see pack(), above.

Endianicity of integers
-----------------------

Integer values can be packed and unpacked in either big-endian (Motorola) or little-endian (Intel) order.  The default is big-endian. Procedures pack_little_endian() and pack_big_endian() set the mode for future packs and unpacks.

Size of ints
------------

The "i" (signed int) and "I" (unsigned int) types can pack and unpack either 16-bit or 32-bit values.  32-bit is the default.  Procedures pack_int_as_short() and pack_int_as_long() change the mode for future packs and unpacks.

To Do List

 - implement other-endian versions of floats (only big-endian supported now).

Procedures for converting real values from input streams. These procedures accept standard IEEE floating point values as strings, usually as read from a file, and return their numeric equivalent as a "real".  The degree of accuracy is likely to vary with different implementations of Icon.

Requires large integers.

Parameter                       Float       Double      Extended    Extended96
=================================================================
Size (bytes:bits)               4:32        8:64        10:80       12:96

Range of binary exponents
  Minimum                      -126        -1022       -16383      -16383
  Maximum                      +127        +1023       +16383      +16383
  Exponent width in bits        8           11          15          15
  Exponent bias                +127        +1023       +16383      +16383

Significand precision
  Bits                          24          53          64          64
  Decimal digits                7-8         15-16       18-19       18-19

Decimal range approximate
  Maximum positive              3.4E+38     1.7E+308    1.1E+4932
  Minimum positive norm         1.2E-38     2.3E-308    1.7E-4932
  Minimum positive denorm       1.5E-45     5.0E-324    1.9E-4951
  Maximum negative denorm      -1.5E-45    -5.0E-324   -1.9E-4951
  Maximum negative norm        -1.2E-38    -2.3E-308   -1.7E-4932
  Minimum negative             -3.4E+38    -1.7E+308   -1.1E+4932
################################################################################
File:
bincvt.icn
********************************************************************************
Description:
Procedures to convert binary data
********************************************************************************
Additional Notes:
unsigned() -- Converts binary byte string into unsigned integer. Detects overflow if number is too large.

This procedure is normally used for processing of binary data read from a file.

raw() -- Puts raw bits of characters of string s into an integer. If the size of s is less than the size of an integer, the bytes are put into the low order part of the integer, with the remaining high order bytes filled with zero.  If the string is too large, the most significant bytes will be lost -- no overflow detection.

This procedure is normally used for processing of binary data read from a file.

rawstring() -- Creates a string consisting of the raw bits in the low order "size" bytes of integer i.

This procedure is normally used for processing of binary data to be written to a file.
################################################################################
File:
binop.icn
********************************************************************************
Description:
Procedure to apply binary operation to list of values
********************************************************************************
Additional Notes:
This procedure applies a binary operation to a list of arguments.

For example,

       binop("+", 1, 2, 3)

returns 6.
################################################################################
File:
bitint.icn
********************************************************************************
Description:
Procedures to convert integers and bit strings
********************************************************************************
Additional Notes:
int2bit(i) produces a string with the bit representation of i.

bit2int(s) produces an integer corresponding to the bit representation i.
################################################################################
File:
bitstr.icn
********************************************************************************
Description:
Procedures for bits in Icon strings
********************************************************************************
Additional Notes:
Procedures for working with strings made up of numeric values represented by strings of an arbitrary number of bits, stored without regard to character boundaries.

In conjunction with the "large integers" feature of Icon, this facility can deal with bitstring segments of arbitrary size.  If "large integers" are not supported, bitstring segments (i.e.  the nbits parameter of BitStringGet and BitStringPut) wider that the integer size of the platform are likely to produce incorrect results.
********************************************************************************
Detail Description:
--------------------------------------------------------------------------------
Section:
Usage of BitStringPut, by example:

       record bit_value(value, nbits)
       ...
       bitString := BitString("")
       while value := get_new_value() do
               BitStringPut(bitString, value.nbits, value.value)
       resultString := BitStringPut(bitString) # output any buffered bits

Note the interesting effect that BitStringPut(bitString), as well as producing the complete string, pads the buffered string to an even character boundary.  This can be dune during construction of a bit string if the effect is desired.

The "value" argument defaults to zero.
--------------------------------------------------------------------------------
Section:
Usage of BitStringGet, by example:

       record bit_value(value, nbits)
       ...
       bitString := BitString(string_of_bits)
       while value := BitStringGet(bitString, nbits) do
               # do something with value

BitStringGet fails when too few bits remain to satisfy a request. However, if bits remain in the string, subsequent calls with fewer bits requested may succeed.  A negative "nbits" value gets the value of the entire remainder of the string, to the byte boundary at its end.

See also: bitstrm.icn
################################################################################
File:     bitstrm.icn
********************************************************************************
Description:
Procedures to read and write strings of bits in files
********************************************************************************
Additional Notes:
Procedures for reading and writing integer values made up of an arbitrary number of bits, stored without regard to character boundaries.
********************************************************************************
Detail Description:
--------------------------------------------------------------------------------
Section:
Usage of BitStreamWrite, by example:

       record bit_value(value, nbits)
       ...
       BitStreamWrite()                        #initialize
       while value := get_new_value() do       # loop to output values
               BitStreamWrite(outfile, value.nbits, value.value)
       BitStreamWrite(outfile)                 # output any buffered bits

Note the interesting effect that BitStreamWrite(outproc), as well asoutputting the complete string, pads the output to an even character boundary.  This can be dune during construction of a bit string if the effect is desired.

The "value" argument defaults to zero.
--------------------------------------------------------------------------------
Section:
Usage of BitStreamRead, by example:

       BitStreamRead()
       while value := BitStreamRead(infile, nbits) do
               # do something with value

BitStringRead fails when too few bits remain to satisfy a request.

See also: bitstr.icn
################################################################################
File:
bkutil.icn
********************************************************************************
Description:
Procedures for HP95LX phone books and appointment books
********************************************************************************
Additional Notes:
Utility procedures for HP95LX phone book and appointment book processing.

See also: abkform.icn, pbkform.icn
################################################################################
File:
bold.icn
********************************************************************************
Description:
Procedures to enbolden and underscore text
********************************************************************************
Additional Notes:
These procedures produce text with interspersed characters suitable for printing to produce the effect of boldface (by over-striking) and underscoring (using backspaces).

       bold(s)        bold version of s

       uscore(s)      underscored version of s
################################################################################
File:
bufread.icn
********************************************************************************
Description:
Procedures for buffered read and lookahead
********************************************************************************
Additional Notes:
Synopsis:

       bufopen(s)      Open a file name s for buffered read and lookahead
       bufread(f)      Read the next line from file f
       bufnext(f, n)   Return the next nth record from file f without changing the next record to be read by bufread
       bufclose(f)     Close file f

These procedures provide a mechanism for looking ahead an arbitrary number of records in an open file while still keeping track of the logical current record and end-of-file. Although similar in intent to the procedures in buffer.icn, these procedures are used differently.  The procedures bufopen, bufread, and bufclose were designed to closely mirror the built-in open, read, and close.

A code segment like

           file := open("name", "r") | stop("open failed")
           while line := read(file) do {
               ...process current line...
           }
           close(file)

can be changed to the following with no difference in behavior:

           file := bufopen("name", "r") | stop("open failed")
           while line := bufread(file) do {
               ...process current line...
           }
           bufclose(file)

However in addition to processing the current line, one may also process subsequent lines BEFORE they are logically read:

           file := bufopen("name", "r") | stop("open failed")
           while line := bufread(file) do {
               ...process current line...
               line := bufnext(file,1) # return next line
               ...process next line...
               line := bufnext(file,2) # return 2nd next line
               ...process 2nd next line...
               ...etc...
           }
           bufclose(file)

In the code above, calls to bufnext do not affect the results of subsequent bufread's.  The bufread procedure always steps through the input file a line at a time without skipping lines whether or not bufnext is called.
********************************************************************************
Detail Description:
--------------------------------------------------------------------------------
Section:
bufopen(s)

Produces a file resulting from opening s for reading ("r" option), but fails if the file cannot be opened.  if s is missing or the value of s is &null, then standard input is opened and &input is returned.  Unlike the Icon open function, bufopen() can and must be called prior to any call to bufread or bufnext involving standard input.  Unlike named files, only one buffered standard input may be open at any given time.

Default:
   s   &null   (indicates &input should be opened for buffered reading)

Errors (from open):
   103     s not string

Errors (new):
   Attempt to open standard input when currently open
--------------------------------------------------------------------------------
Section:
bufread(f)

Produces a string consisting of the next line from f, but fails on end of file. Calls to bufnext do not affect the results of subsequent bufread's. The procedure bufread always steps through a file a line at a time without skipping lines. The procedure bufread fails when a logical end of file is reached, i.e., when the physical end of file has been reached AND the internal buffer is empty.

Default:
   f   &input

Errors:
   f is not a file
   f not opened for buffered reads (includes &input)
--------------------------------------------------------------------------------
Section:
bufnext(f, n)

Produces a string consisting of the nth next line from f after the current line. It fails when the physical end of file has been reached.

Default:
   f   &input
   n   1 (the next line after the current one)

Errors:
   f is not a file
   f not opened for buffered reads (includes &input)
   n not convertible to integer
   n not positive
--------------------------------------------------------------------------------
Section:
bufclose(f)

Produces f after closing it.  Standard input must be closed before it can be reopened using bufopen. If standard input is closed, all lines read using bufnext are lost when it is reopened. In general, there is no practical reason to bufclose and then bufopen standard input. One may want to bufclose standard input to release its internal buffer for garbage collection.

Default:
   f   &input

Errors (from close):
   105     f not file
################################################################################
File:
calendar.icn
********************************************************************************
Description:
Procedures for data and time calculation and conversion
********************************************************************************
Additional Notes:
Procedures in this file supercede several procedures in datetime.icn.
********************************************************************************
Detail Description:
--------------------------------------------------------------------------------
Section:
Setting up

You will probably want to set a platform environment variable "Cal_TimeZone" to an appropriate local time zone ID string before using this library. Look at the time zone data at the end of this source file and choose an ID for your locale. Common ones for USA are "PST", "MST", "CST", and "EST", although there are more specific ones such as "America/Arizona" that handle special rules. If environment variables are not supported for your platform or your implementation of Icon, explicitly specify the default time zone in your program: e.g.

       Cal_CurrentTimeZone := Cal_GetTimeZone("PST").

If your system uses a base year for date calculation that is different from 1970, your can specify it in an environment variable "Cal_DateBaseYear" or set it directly in the global variable by the same name. Unix and Windows use the library's default value of 1970, but Macintosh used to use 1984 (I'm not sure if Apple have yet seen fit to conform to the 1970 quasi-standard). This setting doesn't matter unless you want your "seconds" values to be the same as your system's.
--------------------------------------------------------------------------------
Section:
GMT and local time

GMT (Greenwich Mean Time) is a universal time standard (virtually equivalent to "Coordinated Universal Time" (UTC), except for some millisecond differences).
--------------------------------------------------------------------------------
Section:
Time forms

There are two fundamental date/time forms supported by this library: a form in which computation is easy (the "seconds" form) and a form in which formatting is easy (the "calendar record" form).

    - Seconds -- the time is be represented as an integer that is the number of seconds relative to the beginning of Cal_DateBaseYear, GMT. Cal_DateBaseYear is usually 1970, but can be changed). The "seconds" form is a universal time, independent of locale.

    - Cal_Rec -- a "calendar record", which has fields for date and time components: year, month, day, hour, minutes, seconds and day-of-week. The "Cal_Rec" form is usually in terms of local time, including accounting for daylight savings time according to local rules.
--------------------------------------------------------------------------------
Section:
Notes

    - Several procedures have a final "timeZone" parameter. In those procedures the timeZone parameter is optional and, if omitted, Cal_CurrentTimeZone is used.

    - The time zone table and list consume around 30KB that can be "freed" by setting both Cal_TimeZoneTable and Cal_TimeZoneList to &null. Procedures Cal_GetTimeZoneTable() and Cal_GetTimeZoneList() will re-create the structures and assign them back to their globals. For many applications, those structures are no longer needed after program initialization.

    - The global variables are automatically initialized by the Cal_ procedures. However, if you want to use the globals before using any procedures, they must be explicitly initialized by calling Cal_Init().

    - Time zone records in the time zone structures should be viewed as read-only. If you want to make temporary changes to the fields, copy() the time zone record.
--------------------------------------------------------------------------------
Section:
Global variables

The following global variables are useful in date and time operations (R/O means please don't change it):

    - Cal_SecPerMin	- (R/O) Seconds per minute.
    - Cal_SecPerHour	- (R/O) Seconds per hour.
    - Cal_SecPerDay	- (R/O) Seconds per day.
    - Cal_SecPerWeek	- (R/O) Seconds per week.
    - Cal_MonthNames	- (R/O) List of month names.
    - Cal_DayNames	- (R/O) List of day names.
    - Cal_CurrentTimeZone	- Current default time zone record -- can be changed at any time. Initialized to the time zone whose ID is in environment variable "Cal_TimeZone" if set, or to GMT.
    - Cal_TimeZoneGMT	- (R/O) The GMT time zone record. Can be used as a timeZone parameter to "turn off" conversion to or from local.
    - Cal_DateBaseYear - The base year from which the "seconds" form is calculated, initialized to the value of environment variable "Cal_DateBaseYear" if set, or 1970 (the year used by both Unix and MS-Windows)
    - Cal_TimeZoneTable - A table of time zones keyed by the time zone's ID string
    - Cal_TimeZoneList - A list of time zones ordered by increasing offset from GMT
--------------------------------------------------------------------------------
Section:
Initialization procedure

    Cal_Init()
        Initializes global variables. Called implicitly by the Cal_ procedures.
--------------------------------------------------------------------------------
Section:
Cal_Rec (calendar record) procedures

    Cal_Rec(year,month,day,hour,min,sec,weekday)
        Cal_Rec record constructor. All values are integers in customary US usage (months are 1-12, weekdays are 1-7 with 1 -> Sunday)

    Cal_SecToRec(seconds,timeZone)
        Converts seconds to a Cal_Rec, applying conversion rules of "timeZone". To suppress conversion, specify timeZone = Cal_TimeZoneGMT.

    Cal_RecToSec(calRec,timeZone)
        Converts a Cal_Rec to seconds, applying conversion rules of "timeZone". To suppress conversion, specify timeZone = Cal_TimeZoneGMT.
--------------------------------------------------------------------------------
Section:
Time zone procedures

    Cal_GetTimeZone(timeZoneName)
        Gets a time zone given a time zone ID string. Fails if a time zone for the given ID cannot be produced.

    Cal_GetTimeZoneList()
        Returns the tine zone list that is the value of Cal_TimeZoneList, unless that global has been explicitly set to &null. If the global is null, a new list is built, assigned to Cal_TimeZoneList, and returned.

    Cal_GetTimeZoneTable()
        Returns the tine zone table that is the value of Cal_TimeZoneTable, unless that global has been explicitly set to &null. If the global is null, a new table is built, assigned to Cal_TimeZoneTable, and returned. In building the table, Cal_GetTimeZoneList() is called so global variable Cal_TimeZoneList is also set.
--------------------------------------------------------------------------------
Section:
Date/time calculation procedures

    Cal_LocalToGMTSec(seconds,timeZone)
        Converts seconds from local to GMT using the rules of timeZone.

    Cal_GMTToLocalSec(seconds,timeZone)
        Converts seconds from GMT to local using the rules of timeZone.

    Cal_IsLeapYear(year)
        Returns the number of seconds in a day if year is a leap year, otherwise fails.

    Cal_LeapYearsBetween(loYear,hiYear)
        Returns the count of leap years in the range of years n where loYear <= n < hiYear.

    Cal_IsDST(seconds,timeZone)
        Returns the DST offset in hours if seconds (local time) is in the DST period, otherwise fails.

    Cal_NthWeekdayToSec(year,month,weekday,n,fromDay)
        Returns seconds of nth specified weekday of month, or fails if no such day. This is mainly an internal procedure for DST calculations, but might have other application.
--------------------------------------------------------------------------------
Section:
Date/time formatting procedures

    Cal_DateLineToSec(dateline,timeZone)
        Converts a date in something like Icon's &dateline format (Wednesday, February 11, 1998  12:00 am) to "seconds" form.

    Cal_DateToSec(date,timeZone)
        Converts a date string in something like Icon &date format (1998/02/11) to "seconds" form.

    Cal_SecToDate(seconds,timeZone)
        Converts "seconds" form to a string in Icon's &date format (1998/02/11).

    Cal_SecToDateLine(seconds,timeZone)
        Converts "seconds" form to a string in Icon's &dateline format (Wednesday, February 11, 1998  12:00 am).

    Cal_SecToUnixDate(seconds,timeZone)
        Converts "seconds" form to a string in typical UNIX date/time format (Jan 14 10:24 1991).
--------------------------------------------------------------------------------
Section:
Time-only formatting procedures

    Cal_ClockToSec(seconds)
        Converts a time in the format of &clock (19:34:56) to seconds past midnight.

    Cal_SecToClock(seconds)
        Converts seconds past midnight to a string in the format of &clock (19:34:56).

See also:  datetime.icn, datefns.icn
################################################################################
File:
calendat.icn
********************************************************************************
Description:
Procedure to get date from Julian Day Number
********************************************************************************
Additional Notes:
calendat(j) return a record with the month, day, and year corresponding to the Julian Date Number j.

As the former contents of this file were a direct extract from the IPL file datetime.icn, replace the code with a link to datetime.

record date1(month, day, year)
procedure calendat(julian)

Acknowledgement:  This procedure is based on an algorithm given in "Numerical Recipes; The Art of Scientific Computing"; William H. Press, Brian P. Flannery, Saul A. Teukolsky. and William T. Vetterling; Cambrdayge University Press, 1986.
################################################################################
File:
calls.icn
********************************************************************************
Description:
Procedures for calls as objects
********************************************************************************
Additional Notes:
These procedures deal with procedure invocations that are encapulated in records.
################################################################################
File:
capture.icn
********************************************************************************
Description:
Procedures to echo output to a second file
********************************************************************************
Additional Notes:
Capture is initially called by the user with one argument, the open file  to contain the echoed output. Then it places itself and several shadow  procedures between all calls to write, writes & stop.  The user never need call capture again.

Subsequently, during calls to write, writes, and stop, the approprate shadow procedure gains control and calls capture internally. Capture then constructs a list of only those elements that direct output to &output and calls the original builtin function via the saved name. Upon return the shadow routine calls the the original builtin function  with the full list.

A series of uncaptured output functions have been added to allow output to be directed only to &output.  These are handy for placing progress messages and other comforting information on the screen.
********************************************************************************
Detail Description:
--------------------------------------------------------------------------------
Section:
Example:

     otherfile := open(...,"w")

     capfile :=  capture(open(filename,"w"))

     write("Hello there.",var1,var2," - this should be echoed",
        otherfile,"This should appear once in the other file only")

     uncaptured_writes("This will appear once only.")

     every i := 1 to 10000 do
        if ( i % 100 ) = 0 then

           uncaptured_writes("Progress is ",i,"\r")

     close(capfile)
     close(otherfile)
--------------------------------------------------------------------------------
Section:
Notes:

  1.    stop must be handled specially in its shadow function
  2.    capture is not designed to be turned off
  3.    This may be most useful in systems other than Unix (i.e. that don't have a "tee" command)
  4.    Display has not been captured because
        a) display is usually a debugging aid, and capture was originally intended to capture screen output to a file where a record or audit trail might be required
        b) the display output would be 'down a level' showing the locals at the display_capture_ level, although the depth argument could easily be incremented to adjust for this
        c) write, writes, and stop handle arguments the same way
  5.    An alternative to having two calls would be to have capture call the desired procedure with :
           push(&output,x) ; return p!(y ||| x )
        While this would remove the complexity with stop it would probably be slower
################################################################################
File:
cartog.icn
********************************************************************************
Description:
Procedures for cartographic projection
********************************************************************************
Additional Notes:
These procedures project geographic coordinates.

rectp(x1, y1, x2, y2, xm, ym) defines a rectangular projection.

pptrans(L1, L2) defines a planar projective transformation.

utm(a, f) defines a latitude/longitude to UTM projection.


project(p, L) projects a list of coordinates.

invp(p) returns the inverse of projection p.

compose(p1, p2, ...) creates a composite projection.
********************************************************************************
Detail Description:
--------------------------------------------------------------------------------
Section:
rectp(x1, y1, x2, y2, xm, ym)
returns a rectangular projection in which the point (x1, y1) maps to (x2, y2). If xm is specified, distances in the projected coordinate system are scaled by xm. If ym is also specifed, xm scales x values while ym scales y values.
--------------------------------------------------------------------------------
Section:
pptrans(L1, L2)
returns a planar projective transform that maps the four points in L1 to the four points in L2. Each of the two lists contains 8 coordinates: [x1, y1, x2, y2, x3, y3, x4, y4].
--------------------------------------------------------------------------------
Section:
utm(a, f)
returns a projection from latitude and longitude to Universal Transverse Mercator (UTM) representation. The reference ellipsoid is specified by a, the equatorial radius in metres, and f, the flattening. Alternatively, f can be omitted with a specifying a string, such as "Clarke66"; if a is also omitted, "WGS84" is used. See ellipsoid() in geodat.icn for the list of possible strings.

The input list contains signed numeric values: longitude and latitude, in degrees, in that order (x before y). The output list contains triples: an integer zone number followed by real-valued UTM x and y distances in metres. No "false easting" is applied.
--------------------------------------------------------------------------------
Section:
project(p, L)
applies a projection, reading a list of coordinates and returning a new list of transformed coordinates.
--------------------------------------------------------------------------------
Section:
invp(p)
returns the inverse of projection p, or fails if no inverse projection is available.
--------------------------------------------------------------------------------
Section:
compose(p1, p2, ..., pn)
returns the projection that is thecomposition of the projections p1, p2, ..., pn. The composition applies pn first.
--------------------------------------------------------------------------------
Section:
UTM conversion algorithms are based on:

    Map Projections: A Working Manual
    John P. Snyder
    U.S. Geological Survey Professional Paper 1395
    Washington: Superintendent of Documents, 1987

--------------------------------------------------------------------------------
Section:
Planar projective transformation calculations come from:

    Computing Plane Projective Transformations (Method 1)
    Andrew Zisserman, Robotics Research Group, Oxford
    in CVOnline (R. Fisher, ed.), found 22 February 2000 at:
    http://www.dai.ed.ac.uk/CVonline/LOCAL_COPIES/EPSRC_SSAZ/node11.html
################################################################################
File:
caseless.icn
********************************************************************************
Description:
Procedures to perform caseless scanning
********************************************************************************
Additional Notes:
These procedures are analogous to the standard string-analysis functions except that uppercase letters are considered equivalent to lowercase letters.

anycl(c, s, i1, i2)             succeeds and produces i1 + 1, provided map(s[i1]) is in cset(map(c)) and i2 is greater than i1.  It fails otherwise.

balcl(c1, c2, c3, s, i1, i2)    generates the sequence of integer positions in s preceding a character of cset(map(c1)) in map(s[i1:i2]) that is balanced with respect to characters in cset(map(c2)) and cset(map(c3)), but fails if there is no such position.

findcl(s1, s2, i1, i2)          generates the sequence of integer positions in s2 at which map(s1) occurs as a substring in map(s2[i1:i2]), but fails if there is no such position.

manycl(c, s, i1, i2)            succeeds and produces the position in s after the longest initial sequence of characters in cset(map(c)) within map(s[i1:i2]).  It fails if map(s[i1]) is not in cset(map(c)).

matchcl(s1, s2, i1, i2)         produces i1 + *s1 if map(s1) == map(s2[i1+:=*s1]) but fails otherwise.

uptocl(c, s, i1, i2)            generates the sequence of integer positions in s preceding a character of cset(map(c)) in map(s[i1:i2]).  It fails if there is no such position.

Defaults:
                s, s2       &subject
                i1          &pos if s or s2 is defaulted; otherwise 1
                i2          0
                c1          &cset
                c2          '('
                c3          ')'

Errors:
                101         i1 or i2 not integer
                103         s or s1 or s2 not string
                104         c or c1 or c2 or c3 not cset
################################################################################
File:
codeobj.icn
********************************************************************************
Description:
Procedures to encode and decode Icon data
********************************************************************************
Additional Notes:
These procedures provide a way of storing Icon values as strings and retrieving them.  The procedure encode(x) converts x to a string s that can be converted back to x by decode(s). These procedures handle all kinds of values, including structures of arbitrary complexity and even loops.  For "scalar" types -- null, integer, real, cset, and string --

    decode(encode(x)) === x

For structures types -- list, set, table, and record types -- decode(encode(x)) is, for course, not identical to x, but it has the same "shape" and its elements bear the same relation to the original as if they were encoded and decode individually.

No much can be done with files, functions and procedures, and co-expressions except to preserve type and identification.

The encoding of strings and csets handles all characters in a way that it is safe to write the encoding to a file and read it back.

No particular effort was made to use an encoding of value that minimizes the length of the resulting string. Note, however, that as of Version 7 of Icon, there are no limits on the length of strings that can be written out or read in.
********************************************************************************
Detail Description:
The encoding of a value consists of four parts:  a tag, a length, a type code, and a string of the specified length that encodes the value itself.

The tag is omitted for scalar values that are self-defining. For other values, the tag serves as a unique identification. If such a value appears more than once, only its tag appears after the first encoding. There is, therefore, a type code that distinguishes a label for a previously encoded value from other encodings. Tags are strings of lowercase letters. Since the tag is followed by a digit that starts the length, the two can be distinguished.

The length is simply the length of the encoded value that follows.

The type codes consist of single letters taken from the first character of the type name, with lower- and uppercase used to avoid ambiguities.

Where a structure contains several elements, the encodings of the elements are concatenated. Note that the form of the encoding contains the information needed to separate consecutive elements.

Here are some examples of values and their encodings:

    x                     encode(x)
   -------------------------------------------------------

    1                     "1i1"
    2.0                   "3r2.0"
    &null                 "0n"
    "\377"                "4s\\377"
    '\376\377'            "8c\\376\\377"
    procedure main        "a4pmain"
    co-expression #1 (0)  "b0C"
    []                    "c0L"
    set()                 "d0S"
    table("a")            "e3T1sa"
    L1 := ["hi","there"]  "f11L2shi5sthere"

A loop is illsutrated by

    L2 := []
    put(L2,L2)

for which

    x                     encode(x)
   -------------------------------------------------------

    L2                    "g3L1lg"

Of course, you don't have to know all this to use encode and decode.
################################################################################
################################################################################
################################################################################
################################################################################








